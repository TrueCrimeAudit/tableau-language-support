#!/usr/bin/env node\n// src/tests/runAllTests.ts\n\nimport { execSync } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { generateTestCoverageReport } from './testCoverageReport';\n\n/**\n * R8.1: Comprehensive test runner for all test suites\n * \n * This script orchestrates the execution of all test types (unit, integration,\n * performance, edge case) and generates comprehensive reports.\n */\n\ninterface TestSuiteResult {\n    name: string;\n    passed: boolean;\n    duration: number;\n    testCount: number;\n    passedCount: number;\n    failedCount: number;\n    skippedCount: number;\n    coverage?: {\n        lines: number;\n        functions: number;\n        branches: number;\n        statements: number;\n    };\n    errors: string[];\n}\n\ninterface TestRunSummary {\n    totalDuration: number;\n    totalTests: number;\n    totalPassed: number;\n    totalFailed: number;\n    totalSkipped: number;\n    suites: TestSuiteResult[];\n    overallCoverage: {\n        lines: number;\n        functions: number;\n        branches: number;\n        statements: number;\n    };\n    success: boolean;\n}\n\nclass TestRunner {\n    private results: TestSuiteResult[] = [];\n    private startTime: number = 0;\n    \n    constructor() {\n        this.startTime = Date.now();\n    }\n    \n    /**\n     * Run all test suites\n     */\n    async runAllTests(): Promise<TestRunSummary> {\n        console.log('üöÄ Starting comprehensive test execution...');\n        console.log('=' .repeat(60));\n        \n        // Ensure test results directory exists\n        this.ensureTestResultsDirectory();\n        \n        // Run test suites in order\n        await this.runTestSuite('Unit Tests', 'unit');\n        await this.runTestSuite('Integration Tests', 'integration');\n        await this.runTestSuite('Performance Tests', 'performance');\n        await this.runTestSuite('Edge Case Tests', 'edge');\n        \n        // Generate coverage report\n        await this.generateCoverageReport();\n        \n        // Generate summary\n        const summary = this.generateSummary();\n        \n        // Generate reports\n        await this.generateReports(summary);\n        \n        // Display results\n        this.displayResults(summary);\n        \n        return summary;\n    }\n    \n    /**\n     * Run a specific test suite\n     */\n    private async runTestSuite(name: string, type: string): Promise<void> {\n        console.log(`\\nüìã Running ${name}...`);\n        \n        const startTime = Date.now();\n        let result: TestSuiteResult;\n        \n        try {\n            const testPattern = `src/tests/${type}/**/*.test.ts`;\n            const jestConfig = path.join(__dirname, 'jest.config.js');\n            \n            // Build Jest command\n            const jestCommand = [\n                'npx jest',\n                `--testPathPattern=\"${testPattern}\"`,\n                `--config=\"${jestConfig}\"`,\n                '--verbose',\n                '--coverage',\n                '--json',\n                '--outputFile=test-results/jest-results.json'\n            ].join(' ');\n            \n            console.log(`   Command: ${jestCommand}`);\n            \n            // Execute tests\n            const output = execSync(jestCommand, {\n                encoding: 'utf8',\n                stdio: 'pipe',\n                timeout: 300000 // 5 minutes timeout\n            });\n            \n            // Parse Jest results\n            result = this.parseJestResults(name, output, Date.now() - startTime);\n            \n        } catch (error: any) {\n            // Handle test failures\n            result = {\n                name,\n                passed: false,\n                duration: Date.now() - startTime,\n                testCount: 0,\n                passedCount: 0,\n                failedCount: 0,\n                skippedCount: 0,\n                errors: [error.message || 'Unknown error']\n            };\n            \n            console.error(`   ‚ùå ${name} failed:`, error.message);\n        }\n        \n        this.results.push(result);\n        \n        // Display suite results\n        this.displaySuiteResult(result);\n    }\n    \n    /**\n     * Parse Jest results from JSON output\n     */\n    private parseJestResults(suiteName: string, output: string, duration: number): TestSuiteResult {\n        try {\n            // Try to read Jest JSON results\n            const resultsPath = path.join('test-results', 'jest-results.json');\n            let jestResults: any = {};\n            \n            if (fs.existsSync(resultsPath)) {\n                const resultsContent = fs.readFileSync(resultsPath, 'utf8');\n                jestResults = JSON.parse(resultsContent);\n            }\n            \n            return {\n                name: suiteName,\n                passed: jestResults.success || false,\n                duration,\n                testCount: jestResults.numTotalTests || 0,\n                passedCount: jestResults.numPassedTests || 0,\n                failedCount: jestResults.numFailedTests || 0,\n                skippedCount: jestResults.numPendingTests || 0,\n                coverage: this.extractCoverage(jestResults),\n                errors: this.extractErrors(jestResults)\n            };\n        } catch (error) {\n            return {\n                name: suiteName,\n                passed: false,\n                duration,\n                testCount: 0,\n                passedCount: 0,\n                failedCount: 0,\n                skippedCount: 0,\n                errors: ['Failed to parse test results']\n            };\n        }\n    }\n    \n    /**\n     * Extract coverage information from Jest results\n     */\n    private extractCoverage(jestResults: any): TestSuiteResult['coverage'] {\n        if (jestResults.coverageMap) {\n            const summary = jestResults.coverageMap.getCoverageSummary?.();\n            if (summary) {\n                return {\n                    lines: summary.lines?.pct || 0,\n                    functions: summary.functions?.pct || 0,\n                    branches: summary.branches?.pct || 0,\n                    statements: summary.statements?.pct || 0\n                };\n            }\n        }\n        return undefined;\n    }\n    \n    /**\n     * Extract error messages from Jest results\n     */\n    private extractErrors(jestResults: any): string[] {\n        const errors: string[] = [];\n        \n        if (jestResults.testResults) {\n            jestResults.testResults.forEach((testResult: any) => {\n                if (testResult.message) {\n                    errors.push(testResult.message);\n                }\n            });\n        }\n        \n        return errors;\n    }\n    \n    /**\n     * Generate test coverage report\n     */\n    private async generateCoverageReport(): Promise<void> {\n        console.log('\\nüìä Generating coverage report...');\n        \n        try {\n            await generateTestCoverageReport();\n            console.log('   ‚úÖ Coverage report generated successfully');\n        } catch (error) {\n            console.error('   ‚ùå Failed to generate coverage report:', error);\n        }\n    }\n    \n    /**\n     * Generate test run summary\n     */\n    private generateSummary(): TestRunSummary {\n        const totalDuration = Date.now() - this.startTime;\n        const totalTests = this.results.reduce((sum, r) => sum + r.testCount, 0);\n        const totalPassed = this.results.reduce((sum, r) => sum + r.passedCount, 0);\n        const totalFailed = this.results.reduce((sum, r) => sum + r.failedCount, 0);\n        const totalSkipped = this.results.reduce((sum, r) => sum + r.skippedCount, 0);\n        \n        // Calculate overall coverage\n        const coverageResults = this.results.filter(r => r.coverage);\n        const overallCoverage = {\n            lines: coverageResults.length > 0 \n                ? Math.round(coverageResults.reduce((sum, r) => sum + (r.coverage?.lines || 0), 0) / coverageResults.length)\n                : 0,\n            functions: coverageResults.length > 0\n                ? Math.round(coverageResults.reduce((sum, r) => sum + (r.coverage?.functions || 0), 0) / coverageResults.length)\n                : 0,\n            branches: coverageResults.length > 0\n                ? Math.round(coverageResults.reduce((sum, r) => sum + (r.coverage?.branches || 0), 0) / coverageResults.length)\n                : 0,\n            statements: coverageResults.length > 0\n                ? Math.round(coverageResults.reduce((sum, r) => sum + (r.coverage?.statements || 0), 0) / coverageResults.length)\n                : 0\n        };\n        \n        const success = this.results.every(r => r.passed) && totalFailed === 0;\n        \n        return {\n            totalDuration,\n            totalTests,\n            totalPassed,\n            totalFailed,\n            totalSkipped,\n            suites: this.results,\n            overallCoverage,\n            success\n        };\n    }\n    \n    /**\n     * Generate comprehensive reports\n     */\n    private async generateReports(summary: TestRunSummary): Promise<void> {\n        console.log('\\nüìÑ Generating reports...');\n        \n        // Generate JSON report\n        const jsonReportPath = path.join('test-results', 'test-run-summary.json');\n        fs.writeFileSync(jsonReportPath, JSON.stringify(summary, null, 2));\n        console.log(`   üìã JSON report: ${jsonReportPath}`);\n        \n        // Generate HTML report\n        const htmlReport = this.generateHTMLReport(summary);\n        const htmlReportPath = path.join('test-results', 'test-run-report.html');\n        fs.writeFileSync(htmlReportPath, htmlReport);\n        console.log(`   üåê HTML report: ${htmlReportPath}`);\n        \n        // Generate markdown summary\n        const markdownSummary = this.generateMarkdownSummary(summary);\n        const markdownPath = path.join('test-results', 'test-run-summary.md');\n        fs.writeFileSync(markdownPath, markdownSummary);\n        console.log(`   üìù Markdown summary: ${markdownPath}`);\n    }\n    \n    /**\n     * Display suite result\n     */\n    private displaySuiteResult(result: TestSuiteResult): void {\n        const status = result.passed ? '‚úÖ' : '‚ùå';\n        const duration = (result.duration / 1000).toFixed(2);\n        \n        console.log(`   ${status} ${result.name}`);\n        console.log(`      Tests: ${result.testCount} total, ${result.passedCount} passed, ${result.failedCount} failed`);\n        console.log(`      Duration: ${duration}s`);\n        \n        if (result.coverage) {\n            console.log(`      Coverage: ${result.coverage.lines}% lines, ${result.coverage.functions}% functions`);\n        }\n        \n        if (result.errors.length > 0) {\n            console.log(`      Errors: ${result.errors.length}`);\n            result.errors.slice(0, 3).forEach(error => {\n                console.log(`        - ${error.substring(0, 100)}...`);\n            });\n        }\n    }\n    \n    /**\n     * Display final results\n     */\n    private displayResults(summary: TestRunSummary): void {\n        console.log('\\n' + '='.repeat(60));\n        console.log('üìä TEST RUN SUMMARY');\n        console.log('='.repeat(60));\n        \n        const status = summary.success ? '‚úÖ PASSED' : '‚ùå FAILED';\n        const duration = (summary.totalDuration / 1000).toFixed(2);\n        const successRate = summary.totalTests > 0 \n            ? ((summary.totalPassed / summary.totalTests) * 100).toFixed(1)\n            : '0';\n        \n        console.log(`Status: ${status}`);\n        console.log(`Total Duration: ${duration}s`);\n        console.log(`Tests: ${summary.totalTests} total, ${summary.totalPassed} passed, ${summary.totalFailed} failed, ${summary.totalSkipped} skipped`);\n        console.log(`Success Rate: ${successRate}%`);\n        console.log(`Overall Coverage: ${summary.overallCoverage.lines}% lines, ${summary.overallCoverage.functions}% functions`);\n        \n        console.log('\\nSuite Results:');\n        summary.suites.forEach(suite => {\n            const suiteStatus = suite.passed ? '‚úÖ' : '‚ùå';\n            const suiteDuration = (suite.duration / 1000).toFixed(2);\n            console.log(`  ${suiteStatus} ${suite.name} (${suite.testCount} tests, ${suiteDuration}s)`);\n        });\n        \n        if (!summary.success) {\n            console.log('\\n‚ùå Some tests failed. Check the detailed reports for more information.');\n            process.exit(1);\n        } else {\n            console.log('\\nüéâ All tests passed successfully!');\n        }\n    }\n    \n    /**\n     * Generate HTML report\n     */\n    private generateHTMLReport(summary: TestRunSummary): string {\n        return `\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Test Run Report</title>\n    <style>\n        body { font-family: Arial, sans-serif; margin: 20px; }\n        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; margin-bottom: 20px; }\n        .success { color: #4caf50; }\n        .failure { color: #f44336; }\n        .suite { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }\n        .suite.passed { border-left: 5px solid #4caf50; }\n        .suite.failed { border-left: 5px solid #f44336; }\n        table { width: 100%; border-collapse: collapse; margin: 20px 0; }\n        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }\n        th { background-color: #f2f2f2; }\n        .coverage-bar { background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden; }\n        .coverage-fill { height: 100%; background: #4caf50; }\n    </style>\n</head>\n<body>\n    <div class=\"header\">\n        <h1>Test Run Report</h1>\n        <p><strong>Status:</strong> <span class=\"${summary.success ? 'success' : 'failure'}\">${summary.success ? 'PASSED' : 'FAILED'}</span></p>\n        <p><strong>Duration:</strong> ${(summary.totalDuration / 1000).toFixed(2)}s</p>\n        <p><strong>Tests:</strong> ${summary.totalTests} total, ${summary.totalPassed} passed, ${summary.totalFailed} failed</p>\n        <p><strong>Success Rate:</strong> ${summary.totalTests > 0 ? ((summary.totalPassed / summary.totalTests) * 100).toFixed(1) : '0'}%</p>\n    </div>\n    \n    <h2>Coverage Summary</h2>\n    <table>\n        <tr><th>Metric</th><th>Coverage</th><th>Visual</th></tr>\n        <tr>\n            <td>Lines</td>\n            <td>${summary.overallCoverage.lines}%</td>\n            <td><div class=\"coverage-bar\"><div class=\"coverage-fill\" style=\"width: ${summary.overallCoverage.lines}%\"></div></div></td>\n        </tr>\n        <tr>\n            <td>Functions</td>\n            <td>${summary.overallCoverage.functions}%</td>\n            <td><div class=\"coverage-bar\"><div class=\"coverage-fill\" style=\"width: ${summary.overallCoverage.functions}%\"></div></div></td>\n        </tr>\n        <tr>\n            <td>Branches</td>\n            <td>${summary.overallCoverage.branches}%</td>\n            <td><div class=\"coverage-bar\"><div class=\"coverage-fill\" style=\"width: ${summary.overallCoverage.branches}%\"></div></div></td>\n        </tr>\n    </table>\n    \n    <h2>Test Suites</h2>\n    ${summary.suites.map(suite => `\n        <div class=\"suite ${suite.passed ? 'passed' : 'failed'}\">\n            <h3>${suite.name} ${suite.passed ? '‚úÖ' : '‚ùå'}</h3>\n            <p><strong>Tests:</strong> ${suite.testCount} total, ${suite.passedCount} passed, ${suite.failedCount} failed, ${suite.skippedCount} skipped</p>\n            <p><strong>Duration:</strong> ${(suite.duration / 1000).toFixed(2)}s</p>\n            ${suite.coverage ? `\n                <p><strong>Coverage:</strong> ${suite.coverage.lines}% lines, ${suite.coverage.functions}% functions, ${suite.coverage.branches}% branches</p>\n            ` : ''}\n            ${suite.errors.length > 0 ? `\n                <details>\n                    <summary>Errors (${suite.errors.length})</summary>\n                    <ul>\n                        ${suite.errors.map(error => `<li><pre>${error}</pre></li>`).join('')}\n                    </ul>\n                </details>\n            ` : ''}\n        </div>\n    `).join('')}\n    \n    <footer>\n        <p><em>Generated on ${new Date().toLocaleString()}</em></p>\n    </footer>\n</body>\n</html>\n        `;\n    }\n    \n    /**\n     * Generate markdown summary\n     */\n    private generateMarkdownSummary(summary: TestRunSummary): string {\n        const status = summary.success ? '‚úÖ PASSED' : '‚ùå FAILED';\n        const duration = (summary.totalDuration / 1000).toFixed(2);\n        const successRate = summary.totalTests > 0 \n            ? ((summary.totalPassed / summary.totalTests) * 100).toFixed(1)\n            : '0';\n        \n        return `# Test Run Summary\n\n**Status:** ${status}  \n**Duration:** ${duration}s  \n**Tests:** ${summary.totalTests} total, ${summary.totalPassed} passed, ${summary.totalFailed} failed, ${summary.totalSkipped} skipped  \n**Success Rate:** ${successRate}%  \n\n## Coverage\n\n- **Lines:** ${summary.overallCoverage.lines}%\n- **Functions:** ${summary.overallCoverage.functions}%\n- **Branches:** ${summary.overallCoverage.branches}%\n- **Statements:** ${summary.overallCoverage.statements}%\n\n## Test Suites\n\n${summary.suites.map(suite => {\n    const suiteStatus = suite.passed ? '‚úÖ' : '‚ùå';\n    const suiteDuration = (suite.duration / 1000).toFixed(2);\n    return `### ${suite.name} ${suiteStatus}\n\n- **Tests:** ${suite.testCount} total, ${suite.passedCount} passed, ${suite.failedCount} failed, ${suite.skippedCount} skipped\n- **Duration:** ${suiteDuration}s\n${suite.coverage ? `- **Coverage:** ${suite.coverage.lines}% lines, ${suite.coverage.functions}% functions\\n` : ''}\n${suite.errors.length > 0 ? `- **Errors:** ${suite.errors.length}\\n` : ''}`;\n}).join('\\n\\n')}\n\n---\n\n*Generated on ${new Date().toLocaleString()}*\n`;\n    }\n    \n    /**\n     * Ensure test results directory exists\n     */\n    private ensureTestResultsDirectory(): void {\n        const testResultsDir = 'test-results';\n        if (!fs.existsSync(testResultsDir)) {\n            fs.mkdirSync(testResultsDir, { recursive: true });\n        }\n    }\n}\n\n/**\n * Main execution function\n */\nasync function main(): Promise<void> {\n    const runner = new TestRunner();\n    \n    try {\n        const summary = await runner.runAllTests();\n        \n        // Exit with appropriate code\n        process.exit(summary.success ? 0 : 1);\n    } catch (error) {\n        console.error('‚ùå Test runner failed:', error);\n        process.exit(1);\n    }\n}\n\n// Run if called directly\nif (require.main === module) {\n    main().catch(console.error);\n}\n\nexport { TestRunner, TestRunSummary, TestSuiteResult };\n"