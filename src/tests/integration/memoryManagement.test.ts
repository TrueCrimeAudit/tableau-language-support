// src/tests/integration/memoryManagement.test.ts\n\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { globalMemoryManager, MemoryHelpers } from '../../memoryManager';\nimport { parsedDocumentCache } from '../../common';\nimport { IncrementalParser } from '../../incrementalParser';\nimport { globalDebouncer, RequestType } from '../../requestDebouncer';\n\ndescribe('Memory Management Integration', () => {\n    beforeEach(() => {\n        // Reset global state\n        parsedDocumentCache.clear();\n        \n        // Configure memory manager for testing\n        globalMemoryManager.configure({\n            maxMemoryMB: 50, // Lower threshold for testing\n            cleanupThresholdMB: 40,\n            aggressiveCleanupMB: 60,\n            cacheRetentionMs: 1000, // 1 second for testing\n            enableAutoCleanup: false, // Manual control for testing\n            enableMemoryLogging: false\n        });\n    });\n    \n    afterEach(async () => {\n        await globalDebouncer.flushAllRequests();\n        await globalMemoryManager.forceCleanup('aggressive');\n    });\n    \n    describe('Document Lifecycle Integration', () => {\n        it('should manage memory during document parsing lifecycle', async () => {\n            const documents = Array.from({ length: 20 }, (_, i) => \n                createTestDocument(`\n                    IF [Sales${i}] > 100 THEN\n                        SUM([Profit${i}])\n                    ELSE\n                        AVG([Revenue${i}])\n                    END\n                `, 1, `test://lifecycle${i}.twbl`)\n            );\n            \n            // Simulate document opening and parsing\n            for (const doc of documents) {\n                globalMemoryManager.markDocumentActive(doc.uri);\n                IncrementalParser.parseDocumentIncremental(doc);\n                globalMemoryManager.markDocumentAccessed(doc.uri);\n            }\n            \n            const initialStats = globalMemoryManager.getMemoryStats();\n            expect(initialStats.documentsInCache).toBe(20);\n            \n            // Simulate closing half the documents\n            for (let i = 0; i < 10; i++) {\n                globalMemoryManager.markDocumentInactive(documents[i].uri);\n            }\n            \n            // Wait for documents to become eligible for cleanup\n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            // Force cleanup\n            const cleanupStats = await globalMemoryManager.forceCleanup('normal');\n            \n            const finalStats = globalMemoryManager.getMemoryStats();\n            expect(finalStats.documentsInCache).toBeLessThan(initialStats.documentsInCache);\n            expect(cleanupStats.documentsRemoved).toBeGreaterThan(0);\n        });\n        \n        it('should protect active documents during aggressive cleanup', async () => {\n            const activeDoc = createTestDocument(`\n                CASE [Category]\n                    WHEN 'Furniture' THEN [Sales] * 0.1\n                    WHEN 'Technology' THEN [Sales] * 0.15\n                    ELSE [Sales] * 0.05\n                END\n            `, 1, 'test://active-protected.twbl');\n            \n            const inactiveDocs = Array.from({ length: 15 }, (_, i) => \n                createTestDocument(`COUNT([Orders${i}])`, 1, `test://inactive${i}.twbl`)\n            );\n            \n            // Parse all documents\n            IncrementalParser.parseDocumentIncremental(activeDoc);\n            globalMemoryManager.markDocumentActive(activeDoc.uri);\n            \n            for (const doc of inactiveDocs) {\n                IncrementalParser.parseDocumentIncremental(doc);\n                globalMemoryManager.markDocumentInactive(doc.uri);\n            }\n            \n            // Wait for cleanup eligibility\n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            // Perform aggressive cleanup\n            await globalMemoryManager.forceCleanup('aggressive');\n            \n            // Active document should still be in cache\n            expect(parsedDocumentCache.has(activeDoc.uri)).toBe(true);\n            \n            // Some inactive documents should be removed\n            const remainingInactive = inactiveDocs.filter(doc => \n                parsedDocumentCache.has(doc.uri)\n            );\n            expect(remainingInactive.length).toBeLessThan(inactiveDocs.length);\n        });\n    });\n    \n    describe('Integration with Request Debouncer', () => {\n        it('should coordinate memory cleanup with request debouncing', async () => {\n            const document = createTestDocument(`\n                { FIXED [Region] : \n                    SUM([Sales]) / COUNT([Orders])\n                }\n            `, 1, 'test://debouncer-integration.twbl');\n            \n            // Start multiple debounced requests\n            const mockHandler = jest.fn().mockResolvedValue('result');\n            \n            const requests = [\n                globalDebouncer.debounceRequest(\n                    RequestType.COMPLETION,\n                    { document },\n                    mockHandler,\n                    document.uri,\n                    { line: 1, character: 10 }\n                ),\n                globalDebouncer.debounceRequest(\n                    RequestType.HOVER,\n                    { document },\n                    mockHandler,\n                    document.uri,\n                    { line: 2, character: 15 }\n                )\n            ];\n            \n            // Check initial request queue\n            const initialDebounceStats = globalDebouncer.getDebounceStats();\n            expect(initialDebounceStats.pendingRequests).toBeGreaterThan(0);\n            \n            // Perform memory cleanup (should coordinate with debouncer)\n            const cleanupStats = await globalMemoryManager.forceCleanup('aggressive');\n            \n            // Requests should still complete\n            const results = await Promise.all(requests);\n            expect(results).toEqual(['result', 'result']);\n            \n            // Cleanup should have been coordinated\n            expect(cleanupStats).toHaveProperty('requestsCancelled');\n        });\n        \n        it('should handle memory pressure during high request load', async () => {\n            const documents = Array.from({ length: 10 }, (_, i) => \n                createTestDocument(`FUNCTION${i}([Field])`, 1, `test://load${i}.twbl`)\n            );\n            \n            const mockHandler = jest.fn().mockImplementation(() => \n                new Promise(resolve => setTimeout(() => resolve('result'), 100))\n            );\n            \n            // Create high request load\n            const requests = documents.flatMap(doc => \n                Array.from({ length: 5 }, (_, i) => \n                    globalDebouncer.debounceRequest(\n                        RequestType.COMPLETION,\n                        { document: doc, query: `test${i}` },\n                        mockHandler,\n                        doc.uri,\n                        { line: 0, character: i }\n                    )\n                )\n            );\n            \n            // Parse documents to add to cache\n            documents.forEach(doc => {\n                IncrementalParser.parseDocumentIncremental(doc);\n                globalMemoryManager.markDocumentInactive(doc.uri);\n            });\n            \n            // Monitor memory during load\n            const initialMemory = globalMemoryManager.getMemoryStats();\n            \n            // Simulate memory pressure cleanup\n            if (initialMemory.documentsInCache > 5) {\n                await globalMemoryManager.forceCleanup('normal');\n            }\n            \n            // Requests should still complete despite cleanup\n            const results = await Promise.allSettled(requests);\n            const successfulResults = results.filter(r => r.status === 'fulfilled');\n            \n            expect(successfulResults.length).toBeGreaterThan(0);\n        });\n    });\n    \n    describe('Cache Management Integration', () => {\n        it('should integrate with incremental parser cache management', async () => {\n            const largeDocument = createTestDocument(`\n                // Large document with many expressions\n                ${Array.from({ length: 100 }, (_, i) => `\n                    IF [Field${i}] > ${i} THEN\n                        SUM([Value${i}])\n                    ELSE\n                        AVG([Other${i}])\n                    END\n                `).join('\\n')}\n            `, 1, 'test://large-integration.twbl');\n            \n            // Parse the large document\n            const parsedDoc = IncrementalParser.parseDocumentIncremental(largeDocument);\n            globalMemoryManager.markDocumentActive(largeDocument.uri);\n            \n            expect(parsedDoc.symbols.length).toBeGreaterThan(0);\n            expect(parsedDocumentCache.has(largeDocument.uri)).toBe(true);\n            \n            // Check memory usage\n            const memoryStats = globalMemoryManager.getMemoryStats();\n            expect(memoryStats.cacheMemoryMB).toBeGreaterThan(0);\n            \n            // Mark as inactive and cleanup\n            globalMemoryManager.markDocumentInactive(largeDocument.uri);\n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            const cleanupStats = await globalMemoryManager.forceCleanup('normal');\n            \n            // Document should be removed from cache\n            expect(cleanupStats.documentsRemoved).toBeGreaterThan(0);\n        });\n        \n        it('should handle cache invalidation during memory cleanup', async () => {\n            const documents = Array.from({ length: 15 }, (_, i) => \n                createTestDocument(`MAX([Field${i}])`, 1, `test://invalidation${i}.twbl`)\n            );\n            \n            // Parse and cache all documents\n            documents.forEach(doc => {\n                IncrementalParser.parseDocumentIncremental(doc);\n                globalMemoryManager.markDocumentAccessed(doc.uri);\n            });\n            \n            const initialCacheSize = parsedDocumentCache.size;\n            expect(initialCacheSize).toBe(15);\n            \n            // Mark some as inactive\n            documents.slice(0, 10).forEach(doc => {\n                globalMemoryManager.markDocumentInactive(doc.uri);\n            });\n            \n            // Keep some active\n            documents.slice(10).forEach(doc => {\n                globalMemoryManager.markDocumentActive(doc.uri);\n            });\n            \n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            // Cleanup should remove inactive documents\n            const cleanupStats = await globalMemoryManager.forceCleanup('normal');\n            \n            expect(parsedDocumentCache.size).toBeLessThan(initialCacheSize);\n            expect(cleanupStats.documentsRemoved).toBeGreaterThan(0);\n            \n            // Active documents should remain\n            documents.slice(10).forEach(doc => {\n                expect(parsedDocumentCache.has(doc.uri)).toBe(true);\n            });\n        });\n    });\n    \n    describe('Performance Under Memory Pressure', () => {\n        it('should maintain performance during memory cleanup', async () => {\n            const documents = Array.from({ length: 30 }, (_, i) => \n                createTestDocument(`\n                    CASE [Type${i}]\n                        WHEN 'A' THEN [Value${i}] * 1.1\n                        WHEN 'B' THEN [Value${i}] * 1.2\n                        ELSE [Value${i}]\n                    END\n                `, 1, `test://performance${i}.twbl`)\n            );\n            \n            // Parse all documents\n            const parseStart = Date.now();\n            documents.forEach(doc => {\n                IncrementalParser.parseDocumentIncremental(doc);\n                globalMemoryManager.markDocumentInactive(doc.uri);\n            });\n            const parseTime = Date.now() - parseStart;\n            \n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            // Measure cleanup performance\n            const cleanupStart = Date.now();\n            const cleanupStats = await globalMemoryManager.forceCleanup('aggressive');\n            const cleanupTime = Date.now() - cleanupStart;\n            \n            // Performance should be reasonable\n            expect(parseTime).toBeLessThan(5000); // 5 seconds max for parsing\n            expect(cleanupTime).toBeLessThan(2000); // 2 seconds max for cleanup\n            expect(cleanupStats.documentsRemoved).toBeGreaterThan(0);\n            \n            console.log(`Performance test: Parse=${parseTime}ms, Cleanup=${cleanupTime}ms, Removed=${cleanupStats.documentsRemoved}`);\n        });\n        \n        it('should handle memory monitoring during continuous operation', async () => {\n            const documents = Array.from({ length: 25 }, (_, i) => \n                createTestDocument(`COUNT(DISTINCT [Field${i}])`, 1, `test://monitoring${i}.twbl`)\n            );\n            \n            // Simulate continuous operation\n            for (let cycle = 0; cycle < 3; cycle++) {\n                // Add documents\n                documents.forEach(doc => {\n                    const versionedUri = `${doc.uri}#v${cycle}`;\n                    const versionedDoc = TextDocument.create(\n                        versionedUri,\n                        doc.languageId,\n                        cycle + 1,\n                        doc.getText()\n                    );\n                    \n                    IncrementalParser.parseDocumentIncremental(versionedDoc);\n                    globalMemoryManager.markDocumentActive(versionedUri);\n                    globalMemoryManager.markDocumentAccessed(versionedUri);\n                });\n                \n                // Check memory health\n                const healthStatus = globalMemoryManager.getMemoryHealthStatus();\n                \n                if (healthStatus.status !== 'healthy') {\n                    await globalMemoryManager.forceCleanup('normal');\n                }\n                \n                // Mark previous cycle documents as inactive\n                if (cycle > 0) {\n                    documents.forEach(doc => {\n                        const prevVersionUri = `${doc.uri}#v${cycle - 1}`;\n                        globalMemoryManager.markDocumentInactive(prevVersionUri);\n                    });\n                }\n                \n                await new Promise(resolve => setTimeout(resolve, 100));\n            }\n            \n            const finalStats = globalMemoryManager.getMemoryStats();\n            const finalHealth = globalMemoryManager.getMemoryHealthStatus();\n            \n            // System should remain stable\n            expect(finalStats.documentsInCache).toBeGreaterThan(0);\n            expect(['healthy', 'warning']).toContain(finalHealth.status);\n        });\n    });\n    \n    describe('Error Recovery Integration', () => {\n        it('should handle errors during integrated cleanup', async () => {\n            const documents = Array.from({ length: 10 }, (_, i) => \n                createTestDocument(`ERROR_FUNCTION${i}([Field])`, 1, `test://error${i}.twbl`)\n            );\n            \n            // Parse documents\n            documents.forEach(doc => {\n                try {\n                    IncrementalParser.parseDocumentIncremental(doc);\n                    globalMemoryManager.markDocumentInactive(doc.uri);\n                } catch (error) {\n                    // Some parsing might fail, that's okay for this test\n                }\n            });\n            \n            // Mock an error in cache deletion\n            const originalDelete = parsedDocumentCache.delete;\n            let deleteCallCount = 0;\n            parsedDocumentCache.delete = jest.fn().mockImplementation((key) => {\n                deleteCallCount++;\n                if (deleteCallCount === 3) {\n                    throw new Error('Simulated deletion error');\n                }\n                return originalDelete.call(parsedDocumentCache, key);\n            });\n            \n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            // Cleanup should handle errors gracefully\n            const cleanupStats = await globalMemoryManager.forceCleanup('normal');\n            \n            // Should have attempted cleanup despite errors\n            expect(cleanupStats).toHaveProperty('documentsRemoved');\n            \n            // Restore original method\n            parsedDocumentCache.delete = originalDelete;\n        });\n        \n        it('should maintain system stability during memory pressure', async () => {\n            // Create memory pressure scenario\n            const largeDocuments = Array.from({ length: 20 }, (_, i) => \n                createTestDocument(`\n                    // Large expression ${i}\n                    ${Array.from({ length: 50 }, (_, j) => \n                        `SUM([Field${i}_${j}]) + AVG([Other${i}_${j}])`\n                    ).join(' + ')}\n                `, 1, `test://pressure${i}.twbl`)\n            );\n            \n            // Parse all documents to create memory pressure\n            largeDocuments.forEach(doc => {\n                IncrementalParser.parseDocumentIncremental(doc);\n                globalMemoryManager.markDocumentInactive(doc.uri);\n            });\n            \n            // Check memory health\n            const healthBefore = globalMemoryManager.getMemoryHealthStatus();\n            \n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            // System should handle pressure gracefully\n            if (healthBefore.status === 'critical') {\n                await globalMemoryManager.forceCleanup('aggressive');\n            }\n            \n            const healthAfter = globalMemoryManager.getMemoryHealthStatus();\n            const finalStats = globalMemoryManager.getMemoryStats();\n            \n            // System should be more stable after cleanup\n            expect(finalStats.documentsInCache).toBeGreaterThanOrEqual(0);\n            expect(['healthy', 'warning', 'critical']).toContain(healthAfter.status);\n        });\n    });\n    \n    describe('Helper Functions Integration', () => {\n        it('should provide accurate system-wide memory information', async () => {\n            const documents = Array.from({ length: 8 }, (_, i) => \n                createTestDocument(`MEDIAN([Field${i}])`, 1, `test://helpers${i}.twbl`)\n            );\n            \n            // Parse documents\n            documents.forEach(doc => {\n                IncrementalParser.parseDocumentIncremental(doc);\n                globalMemoryManager.markDocumentAccessed(doc.uri);\n            });\n            \n            // Test helper functions\n            const memoryUsage = MemoryHelpers.getMemoryUsage();\n            expect(memoryUsage.documentsInCache).toBe(8);\n            expect(memoryUsage.cacheMemoryMB).toBeGreaterThan(0);\n            \n            const needsCleanup = MemoryHelpers.needsCleanup();\n            expect(typeof needsCleanup).toBe('boolean');\n            \n            const healthStatus = MemoryHelpers.getHealthStatus();\n            expect(['healthy', 'warning', 'critical']).toContain(healthStatus.status);\n            \n            // Test cleanup helper\n            documents.forEach(doc => {\n                globalMemoryManager.markDocumentInactive(doc.uri);\n            });\n            \n            await new Promise(resolve => setTimeout(resolve, 1100));\n            \n            const cleanupStats = await MemoryHelpers.cleanup(false);\n            expect(cleanupStats.documentsRemoved).toBeGreaterThanOrEqual(0);\n        });\n    });\n});\n\n/**\n * Helper function to create test documents\n */\nfunction createTestDocument(\n    content: string, \n    version: number = 1, \n    uri: string = 'test://test.twbl'\n): TextDocument {\n    return TextDocument.create(uri, 'tableau', version, content);\n}\n"