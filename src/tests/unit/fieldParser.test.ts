// src/tests/unit/fieldParser.test.ts\n\nimport { FieldParser } from '../../fieldParser';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Mock fs module\njest.mock('fs');\nconst mockFs = fs as jest.Mocked<typeof fs>;\n\ndescribe('Field Parser', () => {\n    let fieldParser: FieldParser;\n    \n    const mockFieldDefinitions = `\n        // Field definitions for testing\n        [Sales] : Number\n        [Profit] : Number\n        [Customer Name] : String\n        [Order Date] : Date\n        [Category] : String\n        [Sub-Category] : String\n        [Region] : String\n        [Quantity] : Number\n        [Discount] : Number\n        [Ship Mode] : String\n    `;\n    \n    beforeEach(() => {\n        // Reset mocks\n        jest.clearAllMocks();\n        \n        // Mock file system operations\n        mockFs.existsSync.mockReturnValue(true);\n        mockFs.readFileSync.mockReturnValue(mockFieldDefinitions);\n        \n        // Create field parser instance\n        fieldParser = new FieldParser('test://fields.d.twbl');\n    });\n    \n    describe('Initialization', () => {\n        it('should initialize with valid field definition file', () => {\n            expect(fieldParser).toBeDefined();\n            expect(mockFs.readFileSync).toHaveBeenCalledWith('test://fields.d.twbl', 'utf8');\n        });\n        \n        it('should handle missing field definition file', () => {\n            mockFs.existsSync.mockReturnValue(false);\n            \n            const parser = new FieldParser('nonexistent://fields.d.twbl');\n            \n            expect(parser).toBeDefined();\n            expect(mockFs.readFileSync).not.toHaveBeenCalled();\n        });\n        \n        it('should handle file read errors gracefully', () => {\n            mockFs.readFileSync.mockImplementation(() => {\n                throw new Error('File read error');\n            });\n            \n            expect(() => new FieldParser('test://fields.d.twbl')).not.toThrow();\n        });\n    });\n    \n    describe('Field Information Retrieval', () => {\n        it('should retrieve field information for existing fields', () => {\n            const salesInfo = fieldParser.getFieldInfo('Sales');\n            \n            expect(salesInfo).toBeDefined();\n            expect(salesInfo?.name).toBe('Sales');\n            expect(salesInfo?.type).toBe('Number');\n        });\n        \n        it('should retrieve field information for string fields', () => {\n            const customerInfo = fieldParser.getFieldInfo('Customer Name');\n            \n            expect(customerInfo).toBeDefined();\n            expect(customerInfo?.name).toBe('Customer Name');\n            expect(customerInfo?.type).toBe('String');\n        });\n        \n        it('should retrieve field information for date fields', () => {\n            const dateInfo = fieldParser.getFieldInfo('Order Date');\n            \n            expect(dateInfo).toBeDefined();\n            expect(dateInfo?.name).toBe('Order Date');\n            expect(dateInfo?.type).toBe('Date');\n        });\n        \n        it('should return null for non-existent fields', () => {\n            const unknownInfo = fieldParser.getFieldInfo('Unknown Field');\n            \n            expect(unknownInfo).toBeNull();\n        });\n        \n        it('should handle case-insensitive field lookup', () => {\n            const salesInfo = fieldParser.getFieldInfo('sales');\n            \n            // Depending on implementation, might be case-sensitive or insensitive\n            // This test documents the expected behavior\n            expect(salesInfo).toBeDefined();\n        });\n    });\n    \n    describe('Field List Retrieval', () => {\n        it('should return all available fields', () => {\n            const allFields = fieldParser.getAllFields();\n            \n            expect(allFields).toBeDefined();\n            expect(Array.isArray(allFields)).toBe(true);\n            expect(allFields.length).toBeGreaterThan(0);\n            \n            // Should contain expected fields\n            const fieldNames = allFields.map(f => f.name);\n            expect(fieldNames).toContain('Sales');\n            expect(fieldNames).toContain('Profit');\n            expect(fieldNames).toContain('Customer Name');\n        });\n        \n        it('should return fields with correct types', () => {\n            const allFields = fieldParser.getAllFields();\n            \n            const salesField = allFields.find(f => f.name === 'Sales');\n            expect(salesField?.type).toBe('Number');\n            \n            const customerField = allFields.find(f => f.name === 'Customer Name');\n            expect(customerField?.type).toBe('String');\n            \n            const dateField = allFields.find(f => f.name === 'Order Date');\n            expect(dateField?.type).toBe('Date');\n        });\n        \n        it('should return empty array when no fields are defined', () => {\n            mockFs.readFileSync.mockReturnValue('');\n            const emptyParser = new FieldParser('test://empty.d.twbl');\n            \n            const allFields = emptyParser.getAllFields();\n            \n            expect(allFields).toBeDefined();\n            expect(Array.isArray(allFields)).toBe(true);\n            expect(allFields.length).toBe(0);\n        });\n    });\n    \n    describe('Field Filtering and Search', () => {\n        it('should filter fields by type', () => {\n            const allFields = fieldParser.getAllFields();\n            const numberFields = allFields.filter(f => f.type === 'Number');\n            const stringFields = allFields.filter(f => f.type === 'String');\n            const dateFields = allFields.filter(f => f.type === 'Date');\n            \n            expect(numberFields.length).toBeGreaterThan(0);\n            expect(stringFields.length).toBeGreaterThan(0);\n            expect(dateFields.length).toBeGreaterThan(0);\n            \n            // Verify specific fields are in correct categories\n            expect(numberFields.some(f => f.name === 'Sales')).toBe(true);\n            expect(stringFields.some(f => f.name === 'Customer Name')).toBe(true);\n            expect(dateFields.some(f => f.name === 'Order Date')).toBe(true);\n        });\n        \n        it('should support field name searching', () => {\n            const allFields = fieldParser.getAllFields();\n            \n            // Search for fields containing 'Name'\n            const nameFields = allFields.filter(f => f.name.includes('Name'));\n            expect(nameFields.length).toBeGreaterThan(0);\n            expect(nameFields.some(f => f.name === 'Customer Name')).toBe(true);\n            \n            // Search for fields starting with 'S'\n            const sFields = allFields.filter(f => f.name.startsWith('S'));\n            expect(sFields.some(f => f.name === 'Sales')).toBe(true);\n            expect(sFields.some(f => f.name === 'Sub-Category')).toBe(true);\n        });\n    });\n    \n    describe('Definition File Discovery', () => {\n        it('should find definition file in current directory', () => {\n            const currentDir = '/test/current';\n            const expectedPath = path.join(currentDir, 'fields.d.twbl');\n            \n            mockFs.existsSync.mockImplementation((filePath) => {\n                return filePath === expectedPath;\n            });\n            \n            const foundPath = FieldParser.findDefinitionFile(currentDir);\n            \n            expect(foundPath).toBe(expectedPath);\n        });\n        \n        it('should find definition file in parent directories', () => {\n            const currentDir = '/test/current/subdir';\n            const parentPath = path.join('/test/current', 'fields.d.twbl');\n            \n            mockFs.existsSync.mockImplementation((filePath) => {\n                return filePath === parentPath;\n            });\n            \n            const foundPath = FieldParser.findDefinitionFile(currentDir);\n            \n            expect(foundPath).toBe(parentPath);\n        });\n        \n        it('should return null when no definition file is found', () => {\n            mockFs.existsSync.mockReturnValue(false);\n            \n            const foundPath = FieldParser.findDefinitionFile('/test/nowhere');\n            \n            expect(foundPath).toBeNull();\n        });\n        \n        it('should search in syntaxes directory', () => {\n            const currentDir = '/test/current';\n            const syntaxesPath = path.join(currentDir, 'syntaxes', 'fields.d.twbl');\n            \n            mockFs.existsSync.mockImplementation((filePath) => {\n                return filePath === syntaxesPath;\n            });\n            \n            const foundPath = FieldParser.findDefinitionFile(currentDir);\n            \n            expect(foundPath).toBe(syntaxesPath);\n        });\n    });\n    \n    describe('Field Definition Parsing', () => {\n        it('should parse field definitions with descriptions', () => {\n            const definitionsWithDescriptions = `\n                [Sales] : Number // Total sales amount\n                [Customer Name] : String // Name of the customer\n                [Order Date] : Date // Date when order was placed\n            `;\n            \n            mockFs.readFileSync.mockReturnValue(definitionsWithDescriptions);\n            const parser = new FieldParser('test://with-descriptions.d.twbl');\n            \n            const salesInfo = parser.getFieldInfo('Sales');\n            expect(salesInfo?.description).toContain('Total sales amount');\n            \n            const customerInfo = parser.getFieldInfo('Customer Name');\n            expect(customerInfo?.description).toContain('Name of the customer');\n        });\n        \n        it('should handle malformed field definitions gracefully', () => {\n            const malformedDefinitions = `\n                [Sales] : Number\n                [Invalid Definition\n                [Profit] : Number\n                : String // Missing field name\n                [Category] : // Missing type\n            `;\n            \n            mockFs.readFileSync.mockReturnValue(malformedDefinitions);\n            \n            expect(() => new FieldParser('test://malformed.d.twbl')).not.toThrow();\n            \n            const parser = new FieldParser('test://malformed.d.twbl');\n            \n            // Should still parse valid definitions\n            expect(parser.getFieldInfo('Sales')).toBeDefined();\n            expect(parser.getFieldInfo('Profit')).toBeDefined();\n        });\n        \n        it('should handle empty lines and comments', () => {\n            const definitionsWithComments = `\n                // This is a comment\n                \n                [Sales] : Number\n                \n                // Another comment\n                [Profit] : Number\n                \n            `;\n            \n            mockFs.readFileSync.mockReturnValue(definitionsWithComments);\n            const parser = new FieldParser('test://with-comments.d.twbl');\n            \n            const allFields = parser.getAllFields();\n            expect(allFields.length).toBe(2);\n            expect(allFields.some(f => f.name === 'Sales')).toBe(true);\n            expect(allFields.some(f => f.name === 'Profit')).toBe(true);\n        });\n        \n        it('should handle different field name formats', () => {\n            const variousFormats = `\n                [Simple] : Number\n                [Field With Spaces] : String\n                [Field-With-Dashes] : Date\n                [Field_With_Underscores] : Number\n                [Field123] : String\n            `;\n            \n            mockFs.readFileSync.mockReturnValue(variousFormats);\n            const parser = new FieldParser('test://various-formats.d.twbl');\n            \n            expect(parser.getFieldInfo('Simple')).toBeDefined();\n            expect(parser.getFieldInfo('Field With Spaces')).toBeDefined();\n            expect(parser.getFieldInfo('Field-With-Dashes')).toBeDefined();\n            expect(parser.getFieldInfo('Field_With_Underscores')).toBeDefined();\n            expect(parser.getFieldInfo('Field123')).toBeDefined();\n        });\n    });\n    \n    describe('Error Handling', () => {\n        it('should handle file system errors gracefully', () => {\n            mockFs.readFileSync.mockImplementation(() => {\n                throw new Error('Permission denied');\n            });\n            \n            expect(() => new FieldParser('test://permission-denied.d.twbl')).not.toThrow();\n            \n            const parser = new FieldParser('test://permission-denied.d.twbl');\n            expect(parser.getAllFields()).toEqual([]);\n        });\n        \n        it('should handle invalid file encoding', () => {\n            mockFs.readFileSync.mockReturnValue(Buffer.from([0xFF, 0xFE, 0x00, 0x00]));\n            \n            expect(() => new FieldParser('test://invalid-encoding.d.twbl')).not.toThrow();\n        });\n        \n        it('should handle very large field definition files', () => {\n            const largeDefinitions = Array.from({ length: 10000 }, (_, i) => \n                `[Field${i}] : Number`\n            ).join('\\n');\n            \n            mockFs.readFileSync.mockReturnValue(largeDefinitions);\n            \n            const startTime = Date.now();\n            const parser = new FieldParser('test://large.d.twbl');\n            const duration = Date.now() - startTime;\n            \n            expect(parser).toBeDefined();\n            expect(duration).toBeLessThan(1000); // Should handle large files efficiently\n            \n            const allFields = parser.getAllFields();\n            expect(allFields.length).toBe(10000);\n        });\n    });\n    \n    describe('Performance', () => {\n        it('should retrieve field information quickly', () => {\n            const startTime = Date.now();\n            \n            for (let i = 0; i < 100; i++) {\n                fieldParser.getFieldInfo('Sales');\n                fieldParser.getFieldInfo('Customer Name');\n                fieldParser.getFieldInfo('Order Date');\n            }\n            \n            const duration = Date.now() - startTime;\n            expect(duration).toBeLessThan(100); // Should be very fast\n        });\n        \n        it('should handle repeated getAllFields calls efficiently', () => {\n            const startTime = Date.now();\n            \n            for (let i = 0; i < 50; i++) {\n                fieldParser.getAllFields();\n            }\n            \n            const duration = Date.now() - startTime;\n            expect(duration).toBeLessThan(100); // Should cache results\n        });\n    });\n    \n    describe('Field Validation', () => {\n        it('should validate field names correctly', () => {\n            // Test valid field names\n            expect(fieldParser.getFieldInfo('Sales')).toBeDefined();\n            expect(fieldParser.getFieldInfo('Customer Name')).toBeDefined();\n            \n            // Test invalid field names\n            expect(fieldParser.getFieldInfo('')).toBeNull();\n            expect(fieldParser.getFieldInfo('   ')).toBeNull();\n        });\n        \n        it('should handle special characters in field names', () => {\n            const specialCharDefinitions = `\n                [Field (with parens)] : String\n                [Field [with brackets]] : Number\n                [Field {with braces}] : Date\n                [Field \"with quotes\"] : String\n            `;\n            \n            mockFs.readFileSync.mockReturnValue(specialCharDefinitions);\n            const parser = new FieldParser('test://special-chars.d.twbl');\n            \n            expect(parser.getFieldInfo('Field (with parens)')).toBeDefined();\n            expect(parser.getFieldInfo('Field [with brackets]')).toBeDefined();\n            expect(parser.getFieldInfo('Field {with braces}')).toBeDefined();\n            expect(parser.getFieldInfo('Field \"with quotes\"')).toBeDefined();\n        });\n    });\n    \n    describe('Integration with Language Server', () => {\n        it('should provide field information suitable for hover', () => {\n            const salesInfo = fieldParser.getFieldInfo('Sales');\n            \n            expect(salesInfo).toBeDefined();\n            expect(salesInfo?.name).toBe('Sales');\n            expect(salesInfo?.type).toBe('Number');\n            \n            // Should have properties useful for hover information\n            expect(typeof salesInfo?.name).toBe('string');\n            expect(typeof salesInfo?.type).toBe('string');\n        });\n        \n        it('should provide field list suitable for completion', () => {\n            const allFields = fieldParser.getAllFields();\n            \n            expect(allFields).toBeDefined();\n            expect(Array.isArray(allFields)).toBe(true);\n            \n            // Each field should have properties suitable for completion items\n            allFields.forEach(field => {\n                expect(field).toHaveProperty('name');\n                expect(field).toHaveProperty('type');\n                expect(typeof field.name).toBe('string');\n                expect(typeof field.type).toBe('string');\n            });\n        });\n    });\n});\n"