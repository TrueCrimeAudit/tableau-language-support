// src/tests/unit/slashCommandProvider.test.ts\n\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { Position, CompletionItem, CompletionItemKind } from 'vscode-languageserver';\nimport { provideSlashCommandCompletion, getSlashCommandHelp, validateSlashCommand } from '../../slashCommandProvider';\n\ndescribe('Slash Command Provider', () => {\n    function createTestDocument(content: string): TextDocument {\n        return TextDocument.create('test://test.twbl', 'tableau', 1, content);\n    }\n\n    describe('Slash Command Completion', () => {\n        it('should provide slash command completions after /', () => {\n            const document = createTestDocument('/');\n            const position: Position = { line: 0, character: 1 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toBeDefined();\n            expect(completions.length).toBeGreaterThan(0);\n            \n            // Should include common slash commands\n            const commandLabels = completions.map(c => c.label);\n            expect(commandLabels).toContain('if');\n            expect(commandLabels).toContain('case');\n            expect(commandLabels).toContain('sum');\n            expect(commandLabels).toContain('avg');\n        });\n\n        it('should filter completions based on partial input', () => {\n            const document = createTestDocument('/su');\n            const position: Position = { line: 0, character: 3 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toBeDefined();\n            expect(completions.length).toBeGreaterThan(0);\n            \n            // Should only include commands starting with 'su'\n            const commandLabels = completions.map(c => c.label);\n            expect(commandLabels).toContain('sum');\n            expect(commandLabels.every(label => label.startsWith('su'))).toBe(true);\n        });\n\n        it('should not provide completions when not after /', () => {\n            const document = createTestDocument('SUM([Sales])');\n            const position: Position = { line: 0, character: 5 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toEqual([]);\n        });\n\n        it('should provide completions in the middle of expressions', () => {\n            const document = createTestDocument('IF [Sales] > 100 THEN / ELSE \"Low\" END');\n            const position: Position = { line: 0, character: 24 }; // After the /\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toBeDefined();\n            expect(completions.length).toBeGreaterThan(0);\n        });\n\n        it('should handle multi-line documents', () => {\n            const document = createTestDocument(`\n                IF [Sales] > 100 THEN\n                    /\n                ELSE\n                    \"Low\"\n                END\n            `);\n            const position: Position = { line: 2, character: 21 }; // After the /\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toBeDefined();\n            expect(completions.length).toBeGreaterThan(0);\n        });\n    });\n\n    describe('Command Categories', () => {\n        it('should provide aggregate function commands', () => {\n            const document = createTestDocument('/agg');\n            const position: Position = { line: 0, character: 4 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            const aggregateCommands = completions.filter(c => \n                ['sum', 'avg', 'count', 'min', 'max'].includes(c.label)\n            );\n            \n            expect(aggregateCommands.length).toBeGreaterThan(0);\n            aggregateCommands.forEach(cmd => {\n                expect(cmd.kind).toBe(CompletionItemKind.Function);\n            });\n        });\n\n        it('should provide string function commands', () => {\n            const document = createTestDocument('/str');\n            const position: Position = { line: 0, character: 4 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            const stringCommands = completions.filter(c => \n                ['left', 'right', 'mid', 'len', 'upper', 'lower'].includes(c.label)\n            );\n            \n            expect(stringCommands.length).toBeGreaterThan(0);\n            stringCommands.forEach(cmd => {\n                expect(cmd.kind).toBe(CompletionItemKind.Function);\n            });\n        });\n\n        it('should provide date function commands', () => {\n            const document = createTestDocument('/date');\n            const position: Position = { line: 0, character: 5 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            const dateCommands = completions.filter(c => \n                ['dateadd', 'datediff', 'datepart', 'year', 'month', 'day'].includes(c.label)\n            );\n            \n            expect(dateCommands.length).toBeGreaterThan(0);\n            dateCommands.forEach(cmd => {\n                expect(cmd.kind).toBe(CompletionItemKind.Function);\n            });\n        });\n\n        it('should provide control flow commands', () => {\n            const document = createTestDocument('/');\n            const position: Position = { line: 0, character: 1 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            const controlCommands = completions.filter(c => \n                ['if', 'case', 'iif'].includes(c.label)\n            );\n            \n            expect(controlCommands.length).toBeGreaterThan(0);\n            controlCommands.forEach(cmd => {\n                expect(cmd.kind).toBe(CompletionItemKind.Keyword);\n            });\n        });\n\n        it('should provide LOD expression commands', () => {\n            const document = createTestDocument('/lod');\n            const position: Position = { line: 0, character: 4 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            const lodCommands = completions.filter(c => \n                ['fixed', 'include', 'exclude'].includes(c.label)\n            );\n            \n            expect(lodCommands.length).toBeGreaterThan(0);\n            lodCommands.forEach(cmd => {\n                expect(cmd.kind).toBe(CompletionItemKind.Keyword);\n            });\n        });\n    });\n\n    describe('Command Details and Documentation', () => {\n        it('should provide detailed information for commands', () => {\n            const document = createTestDocument('/sum');\n            const position: Position = { line: 0, character: 4 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            const sumCommand = completions.find(c => c.label === 'sum');\n            \n            expect(sumCommand).toBeDefined();\n            expect(sumCommand?.detail).toBeDefined();\n            expect(sumCommand?.documentation).toBeDefined();\n            expect(sumCommand?.insertText).toBeDefined();\n        });\n\n        it('should provide insert text with placeholders', () => {\n            const document = createTestDocument('/if');\n            const position: Position = { line: 0, character: 3 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            const ifCommand = completions.find(c => c.label === 'if');\n            \n            expect(ifCommand).toBeDefined();\n            expect(ifCommand?.insertText).toContain('${');\n            expect(ifCommand?.insertText).toContain('THEN');\n            expect(ifCommand?.insertText).toContain('ELSE');\n            expect(ifCommand?.insertText).toContain('END');\n        });\n\n        it('should provide function signatures in insert text', () => {\n            const document = createTestDocument('/dateadd');\n            const position: Position = { line: 0, character: 8 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            const dateaddCommand = completions.find(c => c.label === 'dateadd');\n            \n            expect(dateaddCommand).toBeDefined();\n            expect(dateaddCommand?.insertText).toContain('(');\n            expect(dateaddCommand?.insertText).toContain(')');\n            expect(dateaddCommand?.insertText).toContain('${');\n        });\n\n        it('should provide appropriate completion item kinds', () => {\n            const document = createTestDocument('/');\n            const position: Position = { line: 0, character: 1 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            completions.forEach(completion => {\n                expect([\n                    CompletionItemKind.Function,\n                    CompletionItemKind.Keyword,\n                    CompletionItemKind.Snippet\n                ]).toContain(completion.kind);\n            });\n        });\n    });\n\n    describe('Slash Command Help', () => {\n        it('should provide help for specific commands', () => {\n            const help = getSlashCommandHelp('sum');\n            \n            expect(help).toBeDefined();\n            expect(help.command).toBe('sum');\n            expect(help.description).toBeDefined();\n            expect(help.syntax).toBeDefined();\n            expect(help.examples).toBeDefined();\n            expect(help.examples.length).toBeGreaterThan(0);\n        });\n\n        it('should provide help for control flow commands', () => {\n            const help = getSlashCommandHelp('if');\n            \n            expect(help).toBeDefined();\n            expect(help.command).toBe('if');\n            expect(help.description).toContain('conditional');\n            expect(help.syntax).toContain('THEN');\n            expect(help.syntax).toContain('ELSE');\n            expect(help.syntax).toContain('END');\n        });\n\n        it('should provide help for LOD expressions', () => {\n            const help = getSlashCommandHelp('fixed');\n            \n            expect(help).toBeDefined();\n            expect(help.command).toBe('fixed');\n            expect(help.description).toContain('Level of Detail');\n            expect(help.syntax).toContain('{');\n            expect(help.syntax).toContain('}');\n        });\n\n        it('should return undefined for unknown commands', () => {\n            const help = getSlashCommandHelp('unknown-command');\n            expect(help).toBeUndefined();\n        });\n\n        it('should provide comprehensive examples', () => {\n            const help = getSlashCommandHelp('case');\n            \n            expect(help).toBeDefined();\n            expect(help.examples).toBeDefined();\n            expect(help.examples.length).toBeGreaterThan(0);\n            \n            help.examples.forEach(example => {\n                expect(example.code).toBeDefined();\n                expect(example.description).toBeDefined();\n            });\n        });\n    });\n\n    describe('Command Validation', () => {\n        it('should validate correct slash command usage', () => {\n            const validation = validateSlashCommand('/sum([Sales])');\n            \n            expect(validation.isValid).toBe(true);\n            expect(validation.errors).toHaveLength(0);\n        });\n\n        it('should detect invalid slash command syntax', () => {\n            const validation = validateSlashCommand('/sum(');\n            \n            expect(validation.isValid).toBe(false);\n            expect(validation.errors.length).toBeGreaterThan(0);\n            expect(validation.errors[0].message).toContain('syntax');\n        });\n\n        it('should detect unknown slash commands', () => {\n            const validation = validateSlashCommand('/unknowncommand');\n            \n            expect(validation.isValid).toBe(false);\n            expect(validation.errors.length).toBeGreaterThan(0);\n            expect(validation.errors[0].message).toContain('unknown');\n        });\n\n        it('should validate complex slash command expressions', () => {\n            const validation = validateSlashCommand('/if([Sales] > 100, \"High\", \"Low\")');\n            \n            expect(validation.isValid).toBe(true);\n            expect(validation.errors).toHaveLength(0);\n        });\n\n        it('should provide suggestions for invalid commands', () => {\n            const validation = validateSlashCommand('/summ([Sales])');\n            \n            expect(validation.isValid).toBe(false);\n            expect(validation.suggestions).toBeDefined();\n            expect(validation.suggestions?.length).toBeGreaterThan(0);\n            expect(validation.suggestions).toContain('sum');\n        });\n    });\n\n    describe('Context-Aware Completions', () => {\n        it('should provide relevant completions based on context', () => {\n            const document = createTestDocument('IF [Sales] > 100 THEN /');\n            const position: Position = { line: 0, character: 24 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            // In a THEN clause, should prioritize value-returning functions\n            const valueCommands = completions.filter(c => \n                ['sum', 'avg', 'count', 'left', 'right'].includes(c.label)\n            );\n            \n            expect(valueCommands.length).toBeGreaterThan(0);\n        });\n\n        it('should prioritize aggregate functions in appropriate contexts', () => {\n            const document = createTestDocument('{ FIXED [Region] : / }');\n            const position: Position = { line: 0, character: 19 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            // In LOD expression, should prioritize aggregate functions\n            const aggregateCommands = completions.filter(c => \n                ['sum', 'avg', 'count', 'min', 'max'].includes(c.label)\n            );\n            \n            expect(aggregateCommands.length).toBeGreaterThan(0);\n            \n            // Aggregate functions should appear early in the list\n            const firstFew = completions.slice(0, 10).map(c => c.label);\n            expect(firstFew.some(label => ['sum', 'avg', 'count'].includes(label))).toBe(true);\n        });\n\n        it('should handle nested expression contexts', () => {\n            const document = createTestDocument('CASE [Category] WHEN \"Furniture\" THEN / ELSE \"Other\" END');\n            const position: Position = { line: 0, character: 43 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toBeDefined();\n            expect(completions.length).toBeGreaterThan(0);\n        });\n    });\n\n    describe('Performance and Edge Cases', () => {\n        it('should handle large documents efficiently', () => {\n            const largeContent = 'SUM([Sales])\\n'.repeat(1000) + '/';\n            const document = createTestDocument(largeContent);\n            const position: Position = { line: 1000, character: 1 };\n            \n            const startTime = Date.now();\n            const completions = provideSlashCommandCompletion(document, position);\n            const duration = Date.now() - startTime;\n            \n            expect(duration).toBeLessThan(100); // Should be fast\n            expect(completions).toBeDefined();\n        });\n\n        it('should handle malformed documents gracefully', () => {\n            const malformedContent = 'IF [Sales] > 100 THEN THEN ELSE / END';\n            const document = createTestDocument(malformedContent);\n            const position: Position = { line: 0, character: 33 };\n            \n            expect(() => {\n                const completions = provideSlashCommandCompletion(document, position);\n                expect(Array.isArray(completions)).toBe(true);\n            }).not.toThrow();\n        });\n\n        it('should handle edge positions in documents', () => {\n            const document = createTestDocument('/');\n            \n            // Test various edge positions\n            const positions = [\n                { line: 0, character: 0 },  // Before /\n                { line: 0, character: 1 },  // After /\n                { line: 0, character: 2 },  // Beyond end\n                { line: 1, character: 0 }   // Next line\n            ];\n            \n            positions.forEach(position => {\n                expect(() => {\n                    const completions = provideSlashCommandCompletion(document, position);\n                    expect(Array.isArray(completions)).toBe(true);\n                }).not.toThrow();\n            });\n        });\n\n        it('should handle empty documents', () => {\n            const document = createTestDocument('');\n            const position: Position = { line: 0, character: 0 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            expect(completions).toEqual([]);\n        });\n\n        it('should handle documents with only whitespace', () => {\n            const document = createTestDocument('   \\n  \\t  \\n   ');\n            const position: Position = { line: 1, character: 2 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            expect(completions).toEqual([]);\n        });\n    });\n\n    describe('Integration with Other Features', () => {\n        it('should work with field references in commands', () => {\n            const document = createTestDocument('/sum([');\n            const position: Position = { line: 0, character: 6 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            // Should still provide completions even with incomplete field reference\n            expect(Array.isArray(completions)).toBe(true);\n        });\n\n        it('should handle commands with string literals', () => {\n            const document = createTestDocument('/left(\"Hello World\", /');\n            const position: Position = { line: 0, character: 21 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toBeDefined();\n            expect(completions.length).toBeGreaterThan(0);\n        });\n\n        it('should work with nested function calls', () => {\n            const document = createTestDocument('/sum(/avg([Sales]))');\n            const position: Position = { line: 0, character: 6 };\n            \n            const completions = provideSlashCommandCompletion(document, position);\n            \n            expect(completions).toBeDefined();\n            expect(completions.length).toBeGreaterThan(0);\n        });\n    });\n});\n"