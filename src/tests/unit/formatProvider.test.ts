// src/tests/unit/formatProvider.test.ts\n\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { FormattingOptions, TextEdit } from 'vscode-languageserver';\nimport { format, FormattingErrorHandlingAPI } from '../../format';\n\ndescribe('Format Provider', () => {\n    const defaultOptions: FormattingOptions = {\n        tabSize: 4,\n        insertSpaces: true\n    };\n    \n    beforeEach(() => {\n        // Reset error handling configuration\n        FormattingErrorHandlingAPI.configureErrorHandling({\n            MAX_FORMATTING_ATTEMPTS: 3,\n            ENABLE_PARTIAL_FORMATTING: true,\n            PRESERVE_ORIGINAL_ON_FAILURE: true,\n            LOG_FORMATTING_ERRORS: false, // Disable logging in tests\n            FALLBACK_TO_BASIC_FORMATTING: true\n        });\n    });\n    \n    describe('Basic Formatting', () => {\n        it('should format simple expressions', () => {\n            const document = createTestDocument('SUM([Sales])');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            expect(Array.isArray(edits)).toBe(true);\n            \n            if (edits.length > 0) {\n                expect(edits[0].newText).toContain('SUM([Sales])');\n            }\n        });\n        \n        it('should format expressions with proper spacing', () => {\n            const document = createTestDocument('SUM([Sales])+AVG([Profit])');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toMatch(/SUM\\(\\[Sales\\]\\)\\s*\\+\\s*AVG\\(\\[Profit\\]\\)/);\n            }\n        });\n        \n        it('should format field references consistently', () => {\n            const document = createTestDocument('[Sales] + [Profit] * [Quantity]');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('[Sales]');\n                expect(formatted).toContain('[Profit]');\n                expect(formatted).toContain('[Quantity]');\n            }\n        });\n    });\n    \n    describe('IF Statement Formatting', () => {\n        it('should format simple IF statements with proper indentation', () => {\n            const document = createTestDocument('IF [Sales] > 100 THEN \"High\" ELSE \"Low\" END');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('IF');\n                expect(formatted).toContain('THEN');\n                expect(formatted).toContain('ELSE');\n                expect(formatted).toContain('END');\n            }\n        });\n        \n        it('should format multi-line IF statements', () => {\n            const document = createTestDocument(`\n                IF [Sales] > 1000 THEN\n                \"High Sales\"\n                ELSEIF [Sales] > 500 THEN\n                \"Medium Sales\"\n                ELSE\n                \"Low Sales\"\n                END\n            `);\n            \n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('IF');\n                expect(formatted).toContain('ELSEIF');\n                expect(formatted).toContain('ELSE');\n                expect(formatted).toContain('END');\n            }\n        });\n        \n        it('should format nested IF statements', () => {\n            const document = createTestDocument(`\n                IF [Category] = \"Furniture\" THEN\n                    IF [Sales] > 100 THEN \"High Furniture\" ELSE \"Low Furniture\" END\n                ELSE\n                    \"Other\"\n                END\n            `);\n            \n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                // Should maintain nested structure\n                expect(formatted).toContain('IF');\n                expect(formatted).toContain('END');\n            }\n        });\n    });\n    \n    describe('CASE Statement Formatting', () => {\n        it('should format simple CASE statements', () => {\n            const document = createTestDocument('CASE [Category] WHEN \"Furniture\" THEN 1 WHEN \"Technology\" THEN 2 ELSE 0 END');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('CASE');\n                expect(formatted).toContain('WHEN');\n                expect(formatted).toContain('THEN');\n                expect(formatted).toContain('ELSE');\n                expect(formatted).toContain('END');\n            }\n        });\n        \n        it('should format multi-line CASE statements with proper indentation', () => {\n            const document = createTestDocument(`\n                CASE [Category]\n                WHEN \"Furniture\" THEN [Sales] * 0.1\n                WHEN \"Technology\" THEN [Sales] * 0.15\n                WHEN \"Office Supplies\" THEN [Sales] * 0.05\n                ELSE [Sales] * 0.02\n                END\n            `);\n            \n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('CASE');\n                expect(formatted).toContain('WHEN');\n                expect(formatted).toContain('END');\n            }\n        });\n        \n        it('should format nested CASE statements', () => {\n            const document = createTestDocument(`\n                CASE [Region]\n                WHEN \"East\" THEN\n                    CASE [Category]\n                    WHEN \"Furniture\" THEN 1\n                    ELSE 2\n                    END\n                ELSE 0\n                END\n            `);\n            \n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('CASE');\n                expect(formatted).toContain('END');\n            }\n        });\n    });\n    \n    describe('LOD Expression Formatting', () => {\n        it('should format FIXED expressions', () => {\n            const document = createTestDocument('{ FIXED [Region] : SUM([Sales]) }');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('FIXED');\n                expect(formatted).toContain('[Region]');\n                expect(formatted).toContain('SUM([Sales])');\n                expect(formatted).toMatch(/\\{.*\\}/);\n            }\n        });\n        \n        it('should format INCLUDE expressions', () => {\n            const document = createTestDocument('{ INCLUDE [Category] : AVG([Profit]) }');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('INCLUDE');\n                expect(formatted).toContain('[Category]');\n                expect(formatted).toContain('AVG([Profit])');\n            }\n        });\n        \n        it('should format EXCLUDE expressions', () => {\n            const document = createTestDocument('{ EXCLUDE [Sub-Category] : COUNT([Orders]) }');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('EXCLUDE');\n                expect(formatted).toContain('[Sub-Category]');\n                expect(formatted).toContain('COUNT([Orders])');\n            }\n        });\n        \n        it('should format complex LOD expressions', () => {\n            const document = createTestDocument(`\n                {\n                FIXED [Region], [Category] :\n                SUM(\n                IF [Sales] > AVG([Sales]) THEN\n                [Profit]\n                ELSE\n                0\n                END\n                )\n                }\n            `);\n            \n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('FIXED');\n                expect(formatted).toContain('SUM');\n                expect(formatted).toContain('IF');\n            }\n        });\n    });\n    \n    describe('Function Call Formatting', () => {\n        it('should format function calls with proper spacing', () => {\n            const document = createTestDocument('LEFT([Customer Name],5)');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toMatch(/LEFT\\(\\[Customer Name\\],\\s*5\\)/);\n            }\n        });\n        \n        it('should format nested function calls', () => {\n            const document = createTestDocument('UPPER(LEFT([Customer Name], 10))');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('UPPER');\n                expect(formatted).toContain('LEFT');\n                expect(formatted).toContain('[Customer Name]');\n            }\n        });\n        \n        it('should format function calls with multiple parameters', () => {\n            const document = createTestDocument('DATEADD(\\'month\\',1,[Order Date])');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('DATEADD');\n                expect(formatted).toContain('\\'month\\'');\n                expect(formatted).toContain('[Order Date]');\n            }\n        });\n    });\n    \n    describe('Operator Formatting', () => {\n        it('should format arithmetic operators with proper spacing', () => {\n            const document = createTestDocument('[Sales]+[Profit]-[Discount]*[Quantity]/[Price]');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toMatch(/\\[Sales\\]\\s*\\+\\s*\\[Profit\\]/);\n                expect(formatted).toMatch(/\\-\\s*\\[Discount\\]/);\n                expect(formatted).toMatch(/\\*\\s*\\[Quantity\\]/);\n                expect(formatted).toMatch(/\\/\\s*\\[Price\\]/);\n            }\n        });\n        \n        it('should format comparison operators', () => {\n            const document = createTestDocument('[Sales]>100 AND [Profit]<50 OR [Quantity]>=10');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toMatch(/\\[Sales\\]\\s*>\\s*100/);\n                expect(formatted).toMatch(/AND/);\n                expect(formatted).toMatch(/\\[Profit\\]\\s*<\\s*50/);\n                expect(formatted).toMatch(/OR/);\n            }\n        });\n        \n        it('should format logical operators', () => {\n            const document = createTestDocument('[Sales]>100AND[Profit]>50OR[Category]=\"Furniture\"');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toMatch(/\\s+AND\\s+/);\n                expect(formatted).toMatch(/\\s+OR\\s+/);\n            }\n        });\n    });\n    \n    describe('String and Literal Formatting', () => {\n        it('should preserve string literals', () => {\n            const document = createTestDocument('IF [Category] = \"Office Supplies\" THEN \"Office\" ELSE \"Other\" END');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('\"Office Supplies\"');\n                expect(formatted).toContain('\"Office\"');\n                expect(formatted).toContain('\"Other\"');\n            }\n        });\n        \n        it('should handle single quotes in strings', () => {\n            const document = createTestDocument('IF [Customer Name] = \\'John\\'s Store\\' THEN 1 ELSE 0 END');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('\\'John\\'s Store\\'');\n            }\n        });\n        \n        it('should format numeric literals', () => {\n            const document = createTestDocument('[Sales]*1.1+100-0.05');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('1.1');\n                expect(formatted).toContain('100');\n                expect(formatted).toContain('0.05');\n            }\n        });\n    });\n    \n    describe('Comment Formatting', () => {\n        it('should preserve single-line comments', () => {\n            const document = createTestDocument(`\n                // This is a comment\n                SUM([Sales]) // Another comment\n            `);\n            \n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('// This is a comment');\n                expect(formatted).toContain('// Another comment');\n            }\n        });\n        \n        it('should preserve multi-line comments', () => {\n            const document = createTestDocument(`\n                /*\n                 * Multi-line comment\n                 * with multiple lines\n                 */\n                SUM([Sales])\n            `);\n            \n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            \n            if (edits.length > 0) {\n                const formatted = edits[0].newText;\n                expect(formatted).toContain('/*');\n                expect(formatted).toContain('*/');\n                expect(formatted).toContain('Multi-line comment');\n            }\n        });\n    });\n    \n    describe('Formatting Options', () => {\n        it('should respect tab size setting', () => {\n            const document = createTestDocument(`\n                IF [Sales] > 100 THEN\n                    \"High\"\n                ELSE\n                    \"Low\"\n                END\n            `);\n            \n            const tabOptions: FormattingOptions = {\n                tabSize: 2,\n                insertSpaces: true\n            };\n            \n            const edits = format(document, tabOptions);\n            \n            expect(edits).toBeDefined();\n            // Specific indentation testing would depend on implementation\n        });\n        \n        it('should respect insertSpaces setting', () => {\n            const document = createTestDocument(`\n                IF [Sales] > 100 THEN\n                    \"High\"\n                END\n            `);\n            \n            const tabOptions: FormattingOptions = {\n                tabSize: 4,\n                insertSpaces: false\n            };\n            \n            const edits = format(document, tabOptions);\n            \n            expect(edits).toBeDefined();\n            // Tab vs spaces testing would depend on implementation\n        });\n    });\n    \n    describe('Error Handling', () => {\n        it('should handle malformed expressions gracefully', () => {\n            const document = createTestDocument('IF [Sales] > 100 THEN THEN ELSE');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            expect(Array.isArray(edits)).toBe(true);\n            // Should not throw error\n        });\n        \n        it('should handle incomplete expressions', () => {\n            const document = createTestDocument('SUM([Sales] +');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            expect(Array.isArray(edits)).toBe(true);\n        });\n        \n        it('should handle empty documents', () => {\n            const document = createTestDocument('');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            expect(Array.isArray(edits)).toBe(true);\n            expect(edits).toEqual([]);\n        });\n        \n        it('should handle whitespace-only documents', () => {\n            const document = createTestDocument('   \\n  \\t  \\n   ');\n            const edits = format(document, defaultOptions);\n            \n            expect(edits).toBeDefined();\n            expect(Array.isArray(edits)).toBe(true);\n        });\n    });\n    \n    describe('Performance', () => {\n        it('should format quickly for normal-sized documents', () => {\n            const document = createTestDocument(`\n                IF [Sales] > 1000 THEN\n                    CASE [Category]\n                    WHEN \"Furniture\" THEN [Sales] * 0.1\n                    WHEN \"Technology\" THEN [Sales] * 0.15\n                    ELSE [Sales] * 0.05\n                    END\n                ELSE\n                    [Sales] * 0.02\n                END\n            `);\n            \n            const startTime = Date.now();\n            const edits = format(document, defaultOptions);\n            const duration = Date.now() - startTime;\n            \n            expect(edits).toBeDefined();\n            expect(duration).toBeLessThan(100); // Should be fast\n        });\n        \n        it('should handle large documents efficiently', () => {\n            const largeContent = Array.from({ length: 100 }, (_, i) => \n                `IF [Field${i}] > ${i} THEN SUM([Value${i}]) ELSE AVG([Other${i}]) END`\n            ).join('\\n');\n            \n            const document = createTestDocument(largeContent);\n            \n            const startTime = Date.now();\n            const edits = format(document, defaultOptions);\n            const duration = Date.now() - startTime;\n            \n            expect(edits).toBeDefined();\n            expect(duration).toBeLessThan(1000); // Should handle large documents\n        });\n    });\n    \n    describe('Formatting Consistency', () => {\n        it('should produce consistent results for identical input', () => {\n            const content = 'IF [Sales] > 100 THEN \"High\" ELSE \"Low\" END';\n            const document1 = createTestDocument(content);\n            const document2 = createTestDocument(content);\n            \n            const edits1 = format(document1, defaultOptions);\n            const edits2 = format(document2, defaultOptions);\n            \n            expect(edits1).toEqual(edits2);\n        });\n        \n        it('should be idempotent (formatting formatted code should not change it)', () => {\n            const document = createTestDocument('IF [Sales] > 100 THEN \"High\" ELSE \"Low\" END');\n            \n            const firstFormat = format(document, defaultOptions);\n            \n            if (firstFormat.length > 0) {\n                const formattedDocument = createTestDocument(firstFormat[0].newText);\n                const secondFormat = format(formattedDocument, defaultOptions);\n                \n                // Second formatting should produce minimal or no changes\n                expect(secondFormat.length).toBeLessThanOrEqual(1);\n                \n                if (secondFormat.length > 0) {\n                    expect(secondFormat[0].newText).toBe(firstFormat[0].newText);\n                }\n            }\n        });\n    });\n});\n\n/**\n * Helper function to create test documents\n */\nfunction createTestDocument(\n    content: string, \n    version: number = 1, \n    uri: string = 'test://test.twbl'\n): TextDocument {\n    return TextDocument.create(uri, 'tableau', version, content);\n}\n"