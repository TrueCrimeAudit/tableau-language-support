// src/tests/unit/jsdocParser.test.ts\n\nimport { parseJSDoc, extractTypeFromJSDoc, validateJSDocType } from '../../jsdocParser';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\n\ndescribe('JSDoc Parser', () => {\n    function createTestDocument(content: string): TextDocument {\n        return TextDocument.create('test://test.twbl', 'tableau', 1, content);\n    }\n\n    describe('Basic JSDoc Parsing', () => {\n        it('should parse simple JSDoc comments', () => {\n            const comment = '/** @type {string} This is a string variable */';\n            const parsed = parseJSDoc(comment);\n            \n            expect(parsed.type).toBe('string');\n            expect(parsed.description).toBe('This is a string variable');\n            expect(parsed.tags).toHaveLength(1);\n            expect(parsed.tags[0].name).toBe('type');\n            expect(parsed.tags[0].value).toBe('string');\n        });\n\n        it('should parse JSDoc with multiple tags', () => {\n            const comment = `/**\n             * Calculate sales performance\n             * @type {number}\n             * @param {string} region - The sales region\n             * @returns {number} The calculated performance score\n             */`;\n            const parsed = parseJSDoc(comment);\n            \n            expect(parsed.type).toBe('number');\n            expect(parsed.description).toBe('Calculate sales performance');\n            expect(parsed.tags).toHaveLength(3);\n            \n            const typeTag = parsed.tags.find(t => t.name === 'type');\n            expect(typeTag?.value).toBe('number');\n            \n            const paramTag = parsed.tags.find(t => t.name === 'param');\n            expect(paramTag?.value).toBe('string');\n            expect(paramTag?.description).toBe('The sales region');\n            \n            const returnsTag = parsed.tags.find(t => t.name === 'returns');\n            expect(returnsTag?.value).toBe('number');\n            expect(returnsTag?.description).toBe('The calculated performance score');\n        });\n\n        it('should handle JSDoc without type information', () => {\n            const comment = '/** This is just a description */';\n            const parsed = parseJSDoc(comment);\n            \n            expect(parsed.type).toBeUndefined();\n            expect(parsed.description).toBe('This is just a description');\n            expect(parsed.tags).toHaveLength(0);\n        });\n\n        it('should parse inline JSDoc comments', () => {\n            const comment = '/** @type {boolean} */';\n            const parsed = parseJSDoc(comment);\n            \n            expect(parsed.type).toBe('boolean');\n            expect(parsed.description).toBe('');\n            expect(parsed.tags).toHaveLength(1);\n        });\n    });\n\n    describe('Type Extraction', () => {\n        it('should extract simple types', () => {\n            const types = [\n                'string',\n                'number',\n                'boolean',\n                'date',\n                'null',\n                'undefined'\n            ];\n            \n            types.forEach(type => {\n                const comment = `/** @type {${type}} */`;\n                const extracted = extractTypeFromJSDoc(comment);\n                expect(extracted).toBe(type);\n            });\n        });\n\n        it('should extract array types', () => {\n            const arrayTypes = [\n                'string[]',\n                'number[]',\n                'Array<string>',\n                'Array<number>'\n            ];\n            \n            arrayTypes.forEach(type => {\n                const comment = `/** @type {${type}} */`;\n                const extracted = extractTypeFromJSDoc(comment);\n                expect(extracted).toBe(type);\n            });\n        });\n\n        it('should extract union types', () => {\n            const unionTypes = [\n                'string | number',\n                'boolean | null',\n                'string | number | boolean'\n            ];\n            \n            unionTypes.forEach(type => {\n                const comment = `/** @type {${type}} */`;\n                const extracted = extractTypeFromJSDoc(comment);\n                expect(extracted).toBe(type);\n            });\n        });\n\n        it('should extract function types', () => {\n            const functionTypes = [\n                'function',\n                '() => string',\n                '(x: number) => boolean',\n                '(a: string, b: number) => void'\n            ];\n            \n            functionTypes.forEach(type => {\n                const comment = `/** @type {${type}} */`;\n                const extracted = extractTypeFromJSDoc(comment);\n                expect(extracted).toBe(type);\n            });\n        });\n\n        it('should extract object types', () => {\n            const objectTypes = [\n                'object',\n                '{name: string}',\n                '{name: string, age: number}',\n                '{[key: string]: any}'\n            ];\n            \n            objectTypes.forEach(type => {\n                const comment = `/** @type {${type}} */`;\n                const extracted = extractTypeFromJSDoc(comment);\n                expect(extracted).toBe(type);\n            });\n        });\n\n        it('should handle nested generic types', () => {\n            const nestedTypes = [\n                'Array<Array<string>>',\n                'Promise<string>',\n                'Map<string, number>',\n                'Record<string, boolean>'\n            ];\n            \n            nestedTypes.forEach(type => {\n                const comment = `/** @type {${type}} */`;\n                const extracted = extractTypeFromJSDoc(comment);\n                expect(extracted).toBe(type);\n            });\n        });\n    });\n\n    describe('Type Validation', () => {\n        it('should validate basic Tableau types', () => {\n            const validTypes = [\n                'string',\n                'number',\n                'boolean',\n                'date',\n                'field',\n                'dimension',\n                'measure'\n            ];\n            \n            validTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(true);\n                expect(validation.errors).toHaveLength(0);\n            });\n        });\n\n        it('should validate array types', () => {\n            const validArrayTypes = [\n                'string[]',\n                'number[]',\n                'field[]',\n                'Array<string>',\n                'Array<number>'\n            ];\n            \n            validArrayTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(true);\n                expect(validation.errors).toHaveLength(0);\n            });\n        });\n\n        it('should validate union types', () => {\n            const validUnionTypes = [\n                'string | number',\n                'boolean | null',\n                'field | string',\n                'number | undefined'\n            ];\n            \n            validUnionTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(true);\n                expect(validation.errors).toHaveLength(0);\n            });\n        });\n\n        it('should detect invalid types', () => {\n            const invalidTypes = [\n                'invalidtype',\n                'String', // Wrong case\n                'NUMBER', // Wrong case\n                'unknown_type',\n                'custom_type'\n            ];\n            \n            invalidTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(false);\n                expect(validation.errors.length).toBeGreaterThan(0);\n                expect(validation.errors[0].message).toContain('Invalid type');\n            });\n        });\n\n        it('should detect malformed array types', () => {\n            const malformedArrayTypes = [\n                'string[',\n                'number]',\n                'Array<',\n                'Array>',\n                'Array<string',\n                'Array string>'\n            ];\n            \n            malformedArrayTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(false);\n                expect(validation.errors.length).toBeGreaterThan(0);\n            });\n        });\n\n        it('should detect malformed union types', () => {\n            const malformedUnionTypes = [\n                'string |',\n                '| number',\n                'string | | boolean',\n                'string number', // Missing |\n                'string & number' // Wrong operator\n            ];\n            \n            malformedUnionTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(false);\n                expect(validation.errors.length).toBeGreaterThan(0);\n            });\n        });\n    });\n\n    describe('Tableau-Specific Types', () => {\n        it('should recognize Tableau field types', () => {\n            const tableauTypes = [\n                'field',\n                'dimension',\n                'measure',\n                'calculated_field',\n                'parameter',\n                'set',\n                'group'\n            ];\n            \n            tableauTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(true);\n                expect(validation.errors).toHaveLength(0);\n            });\n        });\n\n        it('should recognize Tableau function return types', () => {\n            const functionReturnTypes = [\n                'aggregate',\n                'table_calc',\n                'lod_expression',\n                'string_function',\n                'date_function',\n                'math_function'\n            ];\n            \n            functionReturnTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(true);\n                expect(validation.errors).toHaveLength(0);\n            });\n        });\n\n        it('should validate complex Tableau types', () => {\n            const complexTypes = [\n                'field | parameter',\n                'dimension[]',\n                'Array<measure>',\n                'calculated_field | field',\n                'lod_expression | aggregate'\n            ];\n            \n            complexTypes.forEach(type => {\n                const validation = validateJSDocType(type);\n                expect(validation.isValid).toBe(true);\n                expect(validation.errors).toHaveLength(0);\n            });\n        });\n    });\n\n    describe('Error Messages and Suggestions', () => {\n        it('should provide helpful error messages for invalid types', () => {\n            const validation = validateJSDocType('invalidtype');\n            \n            expect(validation.isValid).toBe(false);\n            expect(validation.errors[0].message).toContain('Invalid type');\n            expect(validation.errors[0].suggestion).toBeDefined();\n        });\n\n        it('should suggest corrections for common mistakes', () => {\n            const commonMistakes = [\n                { input: 'String', suggestion: 'string' },\n                { input: 'Number', suggestion: 'number' },\n                { input: 'Boolean', suggestion: 'boolean' },\n                { input: 'Date', suggestion: 'date' }\n            ];\n            \n            commonMistakes.forEach(({ input, suggestion }) => {\n                const validation = validateJSDocType(input);\n                expect(validation.isValid).toBe(false);\n                expect(validation.errors[0].suggestion).toContain(suggestion);\n            });\n        });\n\n        it('should provide context-aware suggestions', () => {\n            const validation = validateJSDocType('field_reference');\n            \n            expect(validation.isValid).toBe(false);\n            expect(validation.errors[0].suggestion).toContain('field');\n        });\n    });\n\n    describe('Integration with Document Context', () => {\n        it('should parse JSDoc from document comments', () => {\n            const document = createTestDocument(`\n                /** @type {number} Sales performance metric */\n                SUM([Sales])\n            `);\n            \n            const comment = '/** @type {number} Sales performance metric */';\n            const parsed = parseJSDoc(comment);\n            \n            expect(parsed.type).toBe('number');\n            expect(parsed.description).toBe('Sales performance metric');\n        });\n\n        it('should handle multi-line JSDoc in documents', () => {\n            const document = createTestDocument(`\n                /**\n                 * Calculate regional sales performance\n                 * @type {aggregate}\n                 * @param {dimension} region - Sales region\n                 * @returns {number} Performance score\n                 */\n                SUM([Sales]) / COUNT([Orders])\n            `);\n            \n            const comment = `/**\n                 * Calculate regional sales performance\n                 * @type {aggregate}\n                 * @param {dimension} region - Sales region\n                 * @returns {number} Performance score\n                 */`;\n            const parsed = parseJSDoc(comment);\n            \n            expect(parsed.type).toBe('aggregate');\n            expect(parsed.description).toBe('Calculate regional sales performance');\n            expect(parsed.tags).toHaveLength(3);\n        });\n\n        it('should extract type information for variables', () => {\n            const document = createTestDocument(`\n                /** @type {string} */\n                [Customer Name]\n            `);\n            \n            const typeInfo = extractTypeFromJSDoc('/** @type {string} */');\n            expect(typeInfo).toBe('string');\n        });\n    });\n\n    describe('Performance and Edge Cases', () => {\n        it('should handle very long JSDoc comments efficiently', () => {\n            const longDescription = 'A'.repeat(10000);\n            const comment = `/** @type {string} ${longDescription} */`;\n            \n            const startTime = Date.now();\n            const parsed = parseJSDoc(comment);\n            const duration = Date.now() - startTime;\n            \n            expect(duration).toBeLessThan(100); // Should be very fast\n            expect(parsed.type).toBe('string');\n            expect(parsed.description).toBe(longDescription);\n        });\n\n        it('should handle malformed JSDoc gracefully', () => {\n            const malformedComments = [\n                '/** @type */',\n                '/** @type { */',\n                '/** @type } */',\n                '/** @type {string */',\n                '/** @type string} */',\n                '/** @ type {string} */',\n                '/**/'\n            ];\n            \n            malformedComments.forEach(comment => {\n                expect(() => {\n                    const parsed = parseJSDoc(comment);\n                    // Should not crash, but may have undefined or empty values\n                }).not.toThrow();\n            });\n        });\n\n        it('should handle empty or null input', () => {\n            expect(() => {\n                const parsed = parseJSDoc('');\n                expect(parsed.type).toBeUndefined();\n                expect(parsed.description).toBe('');\n                expect(parsed.tags).toHaveLength(0);\n            }).not.toThrow();\n            \n            expect(() => {\n                const parsed = parseJSDoc(null as any);\n                expect(parsed.type).toBeUndefined();\n            }).not.toThrow();\n        });\n\n        it('should handle complex nested type structures', () => {\n            const complexType = 'Array<{name: string, values: Array<number | string>}>';\n            const comment = `/** @type {${complexType}} */`;\n            \n            const extracted = extractTypeFromJSDoc(comment);\n            expect(extracted).toBe(complexType);\n            \n            const validation = validateJSDocType(complexType);\n            // Complex types might not be fully supported, but shouldn't crash\n            expect(typeof validation.isValid).toBe('boolean');\n        });\n    });\n});\n"