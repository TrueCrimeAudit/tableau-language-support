// src/tests/testCoverageReport.ts\n\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n/**\n * R8.1: Comprehensive test coverage reporting system\n * \n * This module provides detailed analysis of test coverage across all components,\n * identifies gaps in testing, and generates actionable reports for improving\n * test coverage and quality.\n */\n\ninterface ComponentTestInfo {\n    componentName: string;\n    sourceFile: string;\n    testFile?: string;\n    hasUnitTests: boolean;\n    hasIntegrationTests: boolean;\n    hasPerformanceTests: boolean;\n    hasEdgeCaseTests: boolean;\n    testCoverage: {\n        lines: number;\n        functions: number;\n        branches: number;\n        statements: number;\n    };\n    testCount: number;\n    lastUpdated: Date;\n    complexity: 'low' | 'medium' | 'high';\n    priority: 'low' | 'medium' | 'high' | 'critical';\n}\n\ninterface TestGap {\n    component: string;\n    gapType: 'missing_unit' | 'missing_integration' | 'missing_performance' | 'missing_edge_case' | 'low_coverage';\n    description: string;\n    recommendation: string;\n    priority: 'low' | 'medium' | 'high' | 'critical';\n}\n\ninterface TestCoverageReport {\n    summary: {\n        totalComponents: number;\n        componentsWithTests: number;\n        overallCoverage: {\n            lines: number;\n            functions: number;\n            branches: number;\n            statements: number;\n        };\n        testCounts: {\n            unit: number;\n            integration: number;\n            performance: number;\n            edgeCase: number;\n        };\n    };\n    components: ComponentTestInfo[];\n    gaps: TestGap[];\n    recommendations: string[];\n    generatedAt: Date;\n}\n\n/**\n * R8.1: Test coverage analyzer and reporter\n */\nexport class TestCoverageAnalyzer {\n    private srcDir: string;\n    private testDir: string;\n    \n    constructor(srcDir: string = 'src', testDir: string = 'src/tests') {\n        this.srcDir = srcDir;\n        this.testDir = testDir;\n    }\n    \n    /**\n     * Generate comprehensive test coverage report\n     */\n    async generateCoverageReport(): Promise<TestCoverageReport> {\n        const components = await this.analyzeComponents();\n        const gaps = this.identifyTestGaps(components);\n        const recommendations = this.generateRecommendations(components, gaps);\n        \n        const summary = this.calculateSummary(components);\n        \n        return {\n            summary,\n            components,\n            gaps,\n            recommendations,\n            generatedAt: new Date()\n        };\n    }\n    \n    /**\n     * Analyze all components for test coverage\n     */\n    private async analyzeComponents(): Promise<ComponentTestInfo[]> {\n        const components: ComponentTestInfo[] = [];\n        \n        // Get all TypeScript files in src directory (excluding tests)\n        const sourceFiles = this.getSourceFiles();\n        \n        for (const sourceFile of sourceFiles) {\n            const componentInfo = await this.analyzeComponent(sourceFile);\n            if (componentInfo) {\n                components.push(componentInfo);\n            }\n        }\n        \n        return components.sort((a, b) => {\n            // Sort by priority, then by coverage\n            const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n            if (a.priority !== b.priority) {\n                return priorityOrder[a.priority] - priorityOrder[b.priority];\n            }\n            return b.testCoverage.lines - a.testCoverage.lines;\n        });\n    }\n    \n    /**\n     * Analyze a single component for test coverage\n     */\n    private async analyzeComponent(sourceFile: string): Promise<ComponentTestInfo | null> {\n        const componentName = this.getComponentName(sourceFile);\n        \n        // Skip certain files\n        if (this.shouldSkipFile(sourceFile)) {\n            return null;\n        }\n        \n        const testFiles = this.findTestFiles(componentName);\n        const testCoverage = await this.getTestCoverage(sourceFile);\n        const complexity = this.assessComplexity(sourceFile);\n        const priority = this.assessPriority(componentName);\n        \n        return {\n            componentName,\n            sourceFile,\n            testFile: testFiles.unit,\n            hasUnitTests: !!testFiles.unit,\n            hasIntegrationTests: !!testFiles.integration,\n            hasPerformanceTests: !!testFiles.performance,\n            hasEdgeCaseTests: !!testFiles.edgeCase,\n            testCoverage,\n            testCount: await this.countTests(testFiles),\n            lastUpdated: this.getFileLastModified(sourceFile),\n            complexity,\n            priority\n        };\n    }\n    \n    /**\n     * Get all source files to analyze\n     */\n    private getSourceFiles(): string[] {\n        const files: string[] = [];\n        \n        const scanDirectory = (dir: string) => {\n            if (!fs.existsSync(dir)) return;\n            \n            const entries = fs.readdirSync(dir, { withFileTypes: true });\n            \n            for (const entry of entries) {\n                const fullPath = path.join(dir, entry.name);\n                \n                if (entry.isDirectory() && entry.name !== 'tests') {\n                    scanDirectory(fullPath);\n                } else if (entry.isFile() && entry.name.endsWith('.ts') && !entry.name.endsWith('.d.ts')) {\n                    files.push(fullPath);\n                }\n            }\n        };\n        \n        scanDirectory(this.srcDir);\n        return files;\n    }\n    \n    /**\n     * Find test files for a component\n     */\n    private findTestFiles(componentName: string): {\n        unit?: string;\n        integration?: string;\n        performance?: string;\n        edgeCase?: string;\n    } {\n        const testFiles: any = {};\n        \n        // Check for unit tests\n        const unitTestPath = path.join(this.testDir, 'unit', `${componentName}.test.ts`);\n        if (fs.existsSync(unitTestPath)) {\n            testFiles.unit = unitTestPath;\n        }\n        \n        // Check for integration tests\n        const integrationTestPath = path.join(this.testDir, 'integration', `${componentName}.test.ts`);\n        if (fs.existsSync(integrationTestPath)) {\n            testFiles.integration = integrationTestPath;\n        }\n        \n        // Check for performance tests\n        const performanceTestPath = path.join(this.testDir, 'performance', `${componentName}.test.ts`);\n        if (fs.existsSync(performanceTestPath)) {\n            testFiles.performance = performanceTestPath;\n        }\n        \n        // Check for edge case tests\n        const edgeCaseTestPath = path.join(this.testDir, 'edge', `${componentName}.test.ts`);\n        if (fs.existsSync(edgeCaseTestPath)) {\n            testFiles.edgeCase = edgeCaseTestPath;\n        }\n        \n        return testFiles;\n    }\n    \n    /**\n     * Get test coverage for a source file\n     */\n    private async getTestCoverage(sourceFile: string): Promise<{\n        lines: number;\n        functions: number;\n        branches: number;\n        statements: number;\n    }> {\n        // This would integrate with Jest coverage reports\n        // For now, return mock data based on file analysis\n        \n        try {\n            const content = fs.readFileSync(sourceFile, 'utf8');\n            const lines = content.split('\\n').length;\n            const functions = (content.match(/function|=>|\\bclass\\b/g) || []).length;\n            const branches = (content.match(/if|else|switch|case|\\?|&&|\\|\\|/g) || []).length;\n            \n            // Estimate coverage based on test file existence\n            const componentName = this.getComponentName(sourceFile);\n            const testFiles = this.findTestFiles(componentName);\n            \n            let coverageMultiplier = 0;\n            if (testFiles.unit) coverageMultiplier += 0.6;\n            if (testFiles.integration) coverageMultiplier += 0.2;\n            if (testFiles.performance) coverageMultiplier += 0.1;\n            if (testFiles.edgeCase) coverageMultiplier += 0.1;\n            \n            return {\n                lines: Math.min(95, Math.round(coverageMultiplier * 100)),\n                functions: Math.min(95, Math.round(coverageMultiplier * 100)),\n                branches: Math.min(90, Math.round(coverageMultiplier * 90)),\n                statements: Math.min(95, Math.round(coverageMultiplier * 100))\n            };\n        } catch (error) {\n            return { lines: 0, functions: 0, branches: 0, statements: 0 };\n        }\n    }\n    \n    /**\n     * Count tests in test files\n     */\n    private async countTests(testFiles: { [key: string]: string }): Promise<number> {\n        let totalTests = 0;\n        \n        for (const testFile of Object.values(testFiles)) {\n            if (testFile && fs.existsSync(testFile)) {\n                try {\n                    const content = fs.readFileSync(testFile, 'utf8');\n                    const testMatches = content.match(/\\bit\\(/g) || [];\n                    totalTests += testMatches.length;\n                } catch (error) {\n                    // Ignore errors reading test files\n                }\n            }\n        }\n        \n        return totalTests;\n    }\n    \n    /**\n     * Assess component complexity\n     */\n    private assessComplexity(sourceFile: string): 'low' | 'medium' | 'high' {\n        try {\n            const content = fs.readFileSync(sourceFile, 'utf8');\n            const lines = content.split('\\n').length;\n            const cyclomaticComplexity = (content.match(/if|else|while|for|switch|case|catch|&&|\\|\\|/g) || []).length;\n            \n            if (lines > 500 || cyclomaticComplexity > 20) {\n                return 'high';\n            } else if (lines > 200 || cyclomaticComplexity > 10) {\n                return 'medium';\n            } else {\n                return 'low';\n            }\n        } catch (error) {\n            return 'medium';\n        }\n    }\n    \n    /**\n     * Assess component priority for testing\n     */\n    private assessPriority(componentName: string): 'low' | 'medium' | 'high' | 'critical' {\n        const criticalComponents = [\n            'documentModel',\n            'diagnosticsProvider',\n            'server',\n            'common'\n        ];\n        \n        const highPriorityComponents = [\n            'hoverProvider',\n            'completionProvider',\n            'signatureProvider',\n            'format',\n            'incrementalParser'\n        ];\n        \n        const mediumPriorityComponents = [\n            'errorRecovery',\n            'fieldParser',\n            'lexer',\n            'memoryManager',\n            'requestDebouncer'\n        ];\n        \n        if (criticalComponents.includes(componentName)) {\n            return 'critical';\n        } else if (highPriorityComponents.includes(componentName)) {\n            return 'high';\n        } else if (mediumPriorityComponents.includes(componentName)) {\n            return 'medium';\n        } else {\n            return 'low';\n        }\n    }\n    \n    /**\n     * Identify gaps in test coverage\n     */\n    private identifyTestGaps(components: ComponentTestInfo[]): TestGap[] {\n        const gaps: TestGap[] = [];\n        \n        for (const component of components) {\n            // Missing unit tests\n            if (!component.hasUnitTests) {\n                gaps.push({\n                    component: component.componentName,\n                    gapType: 'missing_unit',\n                    description: `No unit tests found for ${component.componentName}`,\n                    recommendation: `Create unit tests at ${this.testDir}/unit/${component.componentName}.test.ts`,\n                    priority: component.priority\n                });\n            }\n            \n            // Missing integration tests for critical components\n            if (!component.hasIntegrationTests && (component.priority === 'critical' || component.priority === 'high')) {\n                gaps.push({\n                    component: component.componentName,\n                    gapType: 'missing_integration',\n                    description: `No integration tests found for high-priority component ${component.componentName}`,\n                    recommendation: `Create integration tests at ${this.testDir}/integration/${component.componentName}.test.ts`,\n                    priority: component.priority === 'critical' ? 'high' : 'medium'\n                });\n            }\n            \n            // Missing performance tests for complex components\n            if (!component.hasPerformanceTests && component.complexity === 'high') {\n                gaps.push({\n                    component: component.componentName,\n                    gapType: 'missing_performance',\n                    description: `No performance tests found for complex component ${component.componentName}`,\n                    recommendation: `Create performance tests at ${this.testDir}/performance/${component.componentName}.test.ts`,\n                    priority: 'medium'\n                });\n            }\n            \n            // Low coverage\n            if (component.testCoverage.lines < 80) {\n                gaps.push({\n                    component: component.componentName,\n                    gapType: 'low_coverage',\n                    description: `Low test coverage (${component.testCoverage.lines}%) for ${component.componentName}`,\n                    recommendation: `Improve test coverage by adding more test cases`,\n                    priority: component.priority === 'critical' ? 'high' : 'medium'\n                });\n            }\n            \n            // Missing edge case tests for critical components\n            if (!component.hasEdgeCaseTests && component.priority === 'critical') {\n                gaps.push({\n                    component: component.componentName,\n                    gapType: 'missing_edge_case',\n                    description: `No edge case tests found for critical component ${component.componentName}`,\n                    recommendation: `Create edge case tests at ${this.testDir}/edge/${component.componentName}.test.ts`,\n                    priority: 'medium'\n                });\n            }\n        }\n        \n        return gaps.sort((a, b) => {\n            const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n            return priorityOrder[a.priority] - priorityOrder[b.priority];\n        });\n    }\n    \n    /**\n     * Generate recommendations for improving test coverage\n     */\n    private generateRecommendations(components: ComponentTestInfo[], gaps: TestGap[]): string[] {\n        const recommendations: string[] = [];\n        \n        // Overall coverage recommendations\n        const overallCoverage = this.calculateSummary(components).overallCoverage;\n        if (overallCoverage.lines < 80) {\n            recommendations.push('Overall line coverage is below 80%. Focus on adding unit tests for core components.');\n        }\n        \n        // Critical component recommendations\n        const criticalWithoutTests = components.filter(c => \n            c.priority === 'critical' && (!c.hasUnitTests || c.testCoverage.lines < 85)\n        );\n        if (criticalWithoutTests.length > 0) {\n            recommendations.push(`Critical components need better test coverage: ${criticalWithoutTests.map(c => c.componentName).join(', ')}`);\n        }\n        \n        // Integration test recommendations\n        const needsIntegration = gaps.filter(g => g.gapType === 'missing_integration').length;\n        if (needsIntegration > 0) {\n            recommendations.push(`${needsIntegration} components need integration tests to verify end-to-end functionality.`);\n        }\n        \n        // Performance test recommendations\n        const needsPerformance = gaps.filter(g => g.gapType === 'missing_performance').length;\n        if (needsPerformance > 0) {\n            recommendations.push(`${needsPerformance} complex components need performance tests to ensure scalability.`);\n        }\n        \n        // Test maintenance recommendations\n        const oldTests = components.filter(c => {\n            const daysSinceUpdate = (Date.now() - c.lastUpdated.getTime()) / (1000 * 60 * 60 * 24);\n            return daysSinceUpdate > 30 && c.hasUnitTests;\n        });\n        if (oldTests.length > 0) {\n            recommendations.push(`${oldTests.length} components have tests that haven't been updated in over 30 days. Review for relevance.`);\n        }\n        \n        return recommendations;\n    }\n    \n    /**\n     * Calculate summary statistics\n     */\n    private calculateSummary(components: ComponentTestInfo[]): TestCoverageReport['summary'] {\n        const totalComponents = components.length;\n        const componentsWithTests = components.filter(c => c.hasUnitTests).length;\n        \n        const overallCoverage = {\n            lines: Math.round(components.reduce((sum, c) => sum + c.testCoverage.lines, 0) / totalComponents),\n            functions: Math.round(components.reduce((sum, c) => sum + c.testCoverage.functions, 0) / totalComponents),\n            branches: Math.round(components.reduce((sum, c) => sum + c.testCoverage.branches, 0) / totalComponents),\n            statements: Math.round(components.reduce((sum, c) => sum + c.testCoverage.statements, 0) / totalComponents)\n        };\n        \n        const testCounts = {\n            unit: components.filter(c => c.hasUnitTests).length,\n            integration: components.filter(c => c.hasIntegrationTests).length,\n            performance: components.filter(c => c.hasPerformanceTests).length,\n            edgeCase: components.filter(c => c.hasEdgeCaseTests).length\n        };\n        \n        return {\n            totalComponents,\n            componentsWithTests,\n            overallCoverage,\n            testCounts\n        };\n    }\n    \n    /**\n     * Generate HTML report\n     */\n    async generateHTMLReport(report: TestCoverageReport): Promise<string> {\n        const html = `\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Test Coverage Report</title>\n    <style>\n        body { font-family: Arial, sans-serif; margin: 20px; }\n        .summary { background: #f5f5f5; padding: 20px; border-radius: 5px; margin-bottom: 20px; }\n        .component { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }\n        .critical { border-left: 5px solid #d32f2f; }\n        .high { border-left: 5px solid #f57c00; }\n        .medium { border-left: 5px solid #fbc02d; }\n        .low { border-left: 5px solid #388e3c; }\n        .coverage-bar { background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden; }\n        .coverage-fill { height: 100%; transition: width 0.3s ease; }\n        .good { background: #4caf50; }\n        .warning { background: #ff9800; }\n        .poor { background: #f44336; }\n        .gap { background: #fff3e0; border: 1px solid #ffb74d; padding: 10px; margin: 5px 0; border-radius: 3px; }\n        table { width: 100%; border-collapse: collapse; }\n        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }\n        th { background-color: #f2f2f2; }\n    </style>\n</head>\n<body>\n    <h1>Test Coverage Report</h1>\n    <p>Generated on: ${report.generatedAt.toLocaleString()}</p>\n    \n    <div class=\"summary\">\n        <h2>Summary</h2>\n        <p><strong>Total Components:</strong> ${report.summary.totalComponents}</p>\n        <p><strong>Components with Tests:</strong> ${report.summary.componentsWithTests} (${Math.round(report.summary.componentsWithTests / report.summary.totalComponents * 100)}%)</p>\n        \n        <h3>Overall Coverage</h3>\n        <table>\n            <tr><th>Metric</th><th>Coverage</th><th>Visual</th></tr>\n            <tr>\n                <td>Lines</td>\n                <td>${report.summary.overallCoverage.lines}%</td>\n                <td><div class=\"coverage-bar\"><div class=\"coverage-fill ${this.getCoverageClass(report.summary.overallCoverage.lines)}\" style=\"width: ${report.summary.overallCoverage.lines}%\"></div></div></td>\n            </tr>\n            <tr>\n                <td>Functions</td>\n                <td>${report.summary.overallCoverage.functions}%</td>\n                <td><div class=\"coverage-bar\"><div class=\"coverage-fill ${this.getCoverageClass(report.summary.overallCoverage.functions)}\" style=\"width: ${report.summary.overallCoverage.functions}%\"></div></div></td>\n            </tr>\n            <tr>\n                <td>Branches</td>\n                <td>${report.summary.overallCoverage.branches}%</td>\n                <td><div class=\"coverage-bar\"><div class=\"coverage-fill ${this.getCoverageClass(report.summary.overallCoverage.branches)}\" style=\"width: ${report.summary.overallCoverage.branches}%\"></div></div></td>\n            </tr>\n        </table>\n        \n        <h3>Test Counts</h3>\n        <p>Unit Tests: ${report.summary.testCounts.unit} | Integration Tests: ${report.summary.testCounts.integration} | Performance Tests: ${report.summary.testCounts.performance} | Edge Case Tests: ${report.summary.testCounts.edgeCase}</p>\n    </div>\n    \n    <h2>Components</h2>\n    ${report.components.map(component => `\n        <div class=\"component ${component.priority}\">\n            <h3>${component.componentName} <span style=\"font-size: 0.8em; color: #666;\">(${component.priority} priority, ${component.complexity} complexity)</span></h3>\n            <p><strong>Source:</strong> ${component.sourceFile}</p>\n            <p><strong>Tests:</strong> \n                ${component.hasUnitTests ? '✓ Unit' : '✗ Unit'} | \n                ${component.hasIntegrationTests ? '✓ Integration' : '✗ Integration'} | \n                ${component.hasPerformanceTests ? '✓ Performance' : '✗ Performance'} | \n                ${component.hasEdgeCaseTests ? '✓ Edge Case' : '✗ Edge Case'}\n            </p>\n            <p><strong>Test Count:</strong> ${component.testCount}</p>\n            <p><strong>Coverage:</strong> Lines: ${component.testCoverage.lines}% | Functions: ${component.testCoverage.functions}% | Branches: ${component.testCoverage.branches}%</p>\n            <div class=\"coverage-bar\">\n                <div class=\"coverage-fill ${this.getCoverageClass(component.testCoverage.lines)}\" style=\"width: ${component.testCoverage.lines}%\"></div>\n            </div>\n        </div>\n    `).join('')}\n    \n    <h2>Test Gaps</h2>\n    ${report.gaps.map(gap => `\n        <div class=\"gap\">\n            <strong>${gap.component}</strong> (${gap.priority} priority)<br>\n            ${gap.description}<br>\n            <em>Recommendation: ${gap.recommendation}</em>\n        </div>\n    `).join('')}\n    \n    <h2>Recommendations</h2>\n    <ul>\n        ${report.recommendations.map(rec => `<li>${rec}</li>`).join('')}\n    </ul>\n</body>\n</html>\n        `;\n        \n        return html;\n    }\n    \n    // Helper methods\n    \n    private getComponentName(filePath: string): string {\n        return path.basename(filePath, '.ts');\n    }\n    \n    private shouldSkipFile(filePath: string): boolean {\n        const skipPatterns = [\n            'extension.ts',\n            'server.ts',\n            '.d.ts',\n            'test',\n            'spec'\n        ];\n        \n        return skipPatterns.some(pattern => filePath.includes(pattern));\n    }\n    \n    private getFileLastModified(filePath: string): Date {\n        try {\n            const stats = fs.statSync(filePath);\n            return stats.mtime;\n        } catch (error) {\n            return new Date();\n        }\n    }\n    \n    private getCoverageClass(coverage: number): string {\n        if (coverage >= 80) return 'good';\n        if (coverage >= 60) return 'warning';\n        return 'poor';\n    }\n}\n\n/**\n * R8.1: CLI tool for generating test coverage reports\n */\nexport async function generateTestCoverageReport(): Promise<void> {\n    const analyzer = new TestCoverageAnalyzer();\n    \n    console.log('Analyzing test coverage...');\n    const report = await analyzer.generateCoverageReport();\n    \n    // Generate console report\n    console.log('\\n=== TEST COVERAGE REPORT ===');\n    console.log(`Generated: ${report.generatedAt.toLocaleString()}`);\n    console.log(`\\nSummary:`);\n    console.log(`  Total Components: ${report.summary.totalComponents}`);\n    console.log(`  Components with Tests: ${report.summary.componentsWithTests} (${Math.round(report.summary.componentsWithTests / report.summary.totalComponents * 100)}%)`);\n    console.log(`  Overall Coverage: ${report.summary.overallCoverage.lines}% lines, ${report.summary.overallCoverage.functions}% functions`);\n    \n    console.log(`\\nTest Gaps (${report.gaps.length} total):`);\n    report.gaps.slice(0, 10).forEach(gap => {\n        console.log(`  - ${gap.component}: ${gap.description}`);\n    });\n    \n    console.log(`\\nRecommendations:`);\n    report.recommendations.forEach(rec => {\n        console.log(`  - ${rec}`);\n    });\n    \n    // Generate HTML report\n    const htmlReport = await analyzer.generateHTMLReport(report);\n    const reportPath = path.join('test-results', 'coverage-report.html');\n    \n    // Ensure directory exists\n    const reportDir = path.dirname(reportPath);\n    if (!fs.existsSync(reportDir)) {\n        fs.mkdirSync(reportDir, { recursive: true });\n    }\n    \n    fs.writeFileSync(reportPath, htmlReport);\n    console.log(`\\nHTML report generated: ${reportPath}`);\n    \n    // Generate JSON report for CI/CD\n    const jsonReportPath = path.join('test-results', 'coverage-report.json');\n    fs.writeFileSync(jsonReportPath, JSON.stringify(report, null, 2));\n    console.log(`JSON report generated: ${jsonReportPath}`);\n}\n\n// Run if called directly\nif (require.main === module) {\n    generateTestCoverageReport().catch(console.error);\n}\n"