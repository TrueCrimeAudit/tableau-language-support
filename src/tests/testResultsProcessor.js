// src/tests/testResultsProcessor.js\n\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Custom test results processor for Jest\n * Processes test results and generates additional reports\n */\nmodule.exports = function(results) {\n    // Process and enhance test results\n    const processedResults = processTestResults(results);\n    \n    // Generate custom reports\n    generateCustomReports(processedResults);\n    \n    // Generate performance metrics\n    generatePerformanceMetrics(processedResults);\n    \n    // Generate component coverage summary\n    generateComponentCoverageSummary(processedResults);\n    \n    return results;\n};\n\n/**\n * Process raw test results into a more useful format\n */\nfunction processTestResults(results) {\n    const processed = {\n        summary: {\n            total: results.numTotalTests,\n            passed: results.numPassedTests,\n            failed: results.numFailedTests,\n            skipped: results.numPendingTests,\n            duration: results.testResults.reduce((sum, result) => sum + (result.perfStats?.end - result.perfStats?.start || 0), 0),\n            success: results.success\n        },\n        suites: [],\n        coverage: results.coverageMap ? processCoverageData(results.coverageMap) : null,\n        performance: {\n            slowestTests: [],\n            averageTestTime: 0,\n            totalTestTime: 0\n        }\n    };\n    \n    // Process individual test suites\n    results.testResults.forEach(testResult => {\n        const suite = {\n            name: testResult.testFilePath,\n            duration: testResult.perfStats?.end - testResult.perfStats?.start || 0,\n            tests: testResult.testResults.map(test => ({\n                name: test.fullName,\n                status: test.status,\n                duration: test.duration || 0,\n                errors: test.failureMessages\n            })),\n            coverage: testResult.coverage || null\n        };\n        \n        processed.suites.push(suite);\n        \n        // Track slow tests\n        testResult.testResults.forEach(test => {\n            if (test.duration && test.duration > 1000) { // Tests slower than 1 second\n                processed.performance.slowestTests.push({\n                    name: test.fullName,\n                    suite: testResult.testFilePath,\n                    duration: test.duration\n                });\n            }\n        });\n    });\n    \n    // Sort slowest tests\n    processed.performance.slowestTests.sort((a, b) => b.duration - a.duration);\n    processed.performance.slowestTests = processed.performance.slowestTests.slice(0, 10);\n    \n    // Calculate performance metrics\n    const allTestDurations = processed.suites.flatMap(suite => \n        suite.tests.map(test => test.duration).filter(d => d > 0)\n    );\n    \n    processed.performance.totalTestTime = allTestDurations.reduce((sum, duration) => sum + duration, 0);\n    processed.performance.averageTestTime = allTestDurations.length > 0 \n        ? processed.performance.totalTestTime / allTestDurations.length \n        : 0;\n    \n    return processed;\n}\n\n/**\n * Process coverage data into a more readable format\n */\nfunction processCoverageData(coverageMap) {\n    if (!coverageMap || typeof coverageMap.getCoverageSummary !== 'function') {\n        return null;\n    }\n    \n    const summary = coverageMap.getCoverageSummary();\n    \n    return {\n        lines: {\n            total: summary.lines.total,\n            covered: summary.lines.covered,\n            percentage: summary.lines.pct\n        },\n        functions: {\n            total: summary.functions.total,\n            covered: summary.functions.covered,\n            percentage: summary.functions.pct\n        },\n        branches: {\n            total: summary.branches.total,\n            covered: summary.branches.covered,\n            percentage: summary.branches.pct\n        },\n        statements: {\n            total: summary.statements.total,\n            covered: summary.statements.covered,\n            percentage: summary.statements.pct\n        }\n    };\n}\n\n/**\n * Generate custom test reports\n */\nfunction generateCustomReports(results) {\n    const reportsDir = path.join(__dirname, '../test-results');\n    \n    if (!fs.existsSync(reportsDir)) {\n        fs.mkdirSync(reportsDir, { recursive: true });\n    }\n    \n    // Generate detailed JSON report\n    const detailedReportPath = path.join(reportsDir, 'detailed-results.json');\n    fs.writeFileSync(detailedReportPath, JSON.stringify(results, null, 2));\n    \n    // Generate markdown summary\n    const markdownSummary = generateMarkdownSummary(results);\n    const markdownPath = path.join(reportsDir, 'test-summary.md');\n    fs.writeFileSync(markdownPath, markdownSummary);\n    \n    console.log('📄 Custom reports generated:');\n    console.log(`  - Detailed JSON: ${detailedReportPath}`);\n    console.log(`  - Markdown Summary: ${markdownPath}`);\n}\n\n/**\n * Generate performance metrics report\n */\nfunction generatePerformanceMetrics(results) {\n    const performanceReport = {\n        summary: {\n            totalTestTime: results.performance.totalTestTime,\n            averageTestTime: Math.round(results.performance.averageTestTime),\n            slowestTests: results.performance.slowestTests\n        },\n        suitePerformance: results.suites.map(suite => ({\n            name: path.basename(suite.name),\n            duration: suite.duration,\n            testCount: suite.tests.length,\n            averageTestTime: suite.tests.length > 0 \n                ? Math.round(suite.tests.reduce((sum, test) => sum + test.duration, 0) / suite.tests.length)\n                : 0\n        })).sort((a, b) => b.duration - a.duration),\n        recommendations: generatePerformanceRecommendations(results)\n    };\n    \n    const performancePath = path.join(__dirname, '../test-results/performance-metrics.json');\n    fs.writeFileSync(performancePath, JSON.stringify(performanceReport, null, 2));\n    \n    console.log(`⚡ Performance metrics: ${performancePath}`);\n}\n\n/**\n * Generate component coverage summary\n */\nfunction generateComponentCoverageSummary(results) {\n    if (!results.coverage) {\n        return;\n    }\n    \n    const componentCoverage = {\n        overall: results.coverage,\n        components: {\n            'Document Model': results.coverage, // Would need actual per-file coverage\n            'Diagnostics Provider': results.coverage,\n            'Hover Provider': results.coverage,\n            'Completion Provider': results.coverage,\n            'Signature Provider': results.coverage,\n            'Format Provider': results.coverage,\n            'Lexer': results.coverage,\n            'Field Parser': results.coverage,\n            'Memory Manager': results.coverage,\n            'Request Debouncer': results.coverage\n        },\n        recommendations: generateCoverageRecommendations(results.coverage)\n    };\n    \n    const coveragePath = path.join(__dirname, '../test-results/component-coverage.json');\n    fs.writeFileSync(coveragePath, JSON.stringify(componentCoverage, null, 2));\n    \n    console.log(`📊 Component coverage: ${coveragePath}`);\n}\n\n/**\n * Generate markdown summary report\n */\nfunction generateMarkdownSummary(results) {\n    const { summary, performance, coverage } = results;\n    \n    return `# Tableau LSP Test Results\n\n## Summary\n\n- **Total Tests:** ${summary.total}\n- **Passed:** ${summary.passed} ✅\n- **Failed:** ${summary.failed} ❌\n- **Skipped:** ${summary.skipped} ⏭️\n- **Success Rate:** ${((summary.passed / summary.total) * 100).toFixed(1)}%\n- **Total Duration:** ${(summary.duration / 1000).toFixed(2)}s\n\n## Performance Metrics\n\n- **Total Test Time:** ${(performance.totalTestTime / 1000).toFixed(2)}s\n- **Average Test Time:** ${performance.averageTestTime.toFixed(0)}ms\n\n### Slowest Tests\n\n${performance.slowestTests.map((test, index) => \n    `${index + 1}. **${test.name}** - ${test.duration}ms`\n).join('\\n')}\n\n${coverage ? `## Coverage Summary\n\n- **Lines:** ${coverage.lines.percentage.toFixed(1)}% (${coverage.lines.covered}/${coverage.lines.total})\n- **Functions:** ${coverage.functions.percentage.toFixed(1)}% (${coverage.functions.covered}/${coverage.functions.total})\n- **Branches:** ${coverage.branches.percentage.toFixed(1)}% (${coverage.branches.covered}/${coverage.branches.total})\n- **Statements:** ${coverage.statements.percentage.toFixed(1)}% (${coverage.statements.covered}/${coverage.statements.total})` : ''}\n\n## Test Suites\n\n${results.suites.map(suite => \n    `### ${path.basename(suite.name)}\\n\\n- **Duration:** ${suite.duration}ms\\n- **Tests:** ${suite.tests.length}\\n- **Status:** ${suite.tests.every(t => t.status === 'passed') ? '✅ All Passed' : '❌ Some Failed'}`\n).join('\\n\\n')}\n\n---\n\n*Generated on ${new Date().toISOString()}*\n`;\n}\n\n/**\n * Generate performance recommendations\n */\nfunction generatePerformanceRecommendations(results) {\n    const recommendations = [];\n    \n    if (results.performance.averageTestTime > 500) {\n        recommendations.push('Consider optimizing test setup/teardown - average test time is high');\n    }\n    \n    if (results.performance.slowestTests.length > 5) {\n        recommendations.push('Multiple slow tests detected - consider performance optimization');\n    }\n    \n    if (results.summary.duration > 60000) {\n        recommendations.push('Total test suite duration is high - consider parallel execution');\n    }\n    \n    return recommendations;\n}\n\n/**\n * Generate coverage recommendations\n */\nfunction generateCoverageRecommendations(coverage) {\n    const recommendations = [];\n    \n    if (coverage.lines.percentage < 80) {\n        recommendations.push('Line coverage is below 80% - add more unit tests');\n    }\n    \n    if (coverage.branches.percentage < 75) {\n        recommendations.push('Branch coverage is low - test more conditional logic paths');\n    }\n    \n    if (coverage.functions.percentage < 85) {\n        recommendations.push('Function coverage could be improved - ensure all functions are tested');\n    }\n    \n    return recommendations;\n}\n"