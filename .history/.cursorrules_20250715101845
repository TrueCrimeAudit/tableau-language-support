# Universal Principles for All Contributors and AI Assistants

These principles are mandatory for all development on this project, and must be followed in addition to the Tableau/LSP-specific rules below.

## 1. Mandatory Research & Tool Usage
- Always research official documentation and best practices before coding or refactoring.
- For complex tasks, use sequential/stepwise thinking: break down features, debugging, and architecture into concrete, ordered steps.
- Analyze recent git history and file-specific changes before modifying code.
- Always validate code (TypeScript/ESLint) before marking a task as complete.

## 2. Required Questions Before Implementation
- Always clarify user experience, configuration, integration, error handling, performance, security, and maintenance before starting.
- Never assume‚Äîexplicitly ask about edge cases, constraints, and expectations.

## 3. Code Quality Standards
- Write clear, obvious code‚Äîno clever tricks.
- Use descriptive naming and comment only on the ‚Äúwhy.‚Äù
- Each function should have a single responsibility.
- Handle errors explicitly and visibly.
- Optimize only after measuring performance.
- Keep code as simple as possible.

## 4. Honest Technical Assessment
- Always provide a candid assessment of limitations, risks, and tradeoffs.
- Quantify performance, security, and complexity impacts.
- If uncertain, state so explicitly.

## 5. Preserve Context and Documentation
- Retain technical context, rationale, and cross-references.
- Remove only redundant, obsolete, or decorative information.

## 6. Version Control and Commits
- Use Conventional Commits v1.0.0 for all changes.
- One logical change per commit, with context and references.
- Never mention ‚ÄúClaude‚Äù or ‚ÄúAI‚Äù in commit messages.

## 7. Development Workflow
- Always: Understand context ‚Üí Research current state ‚Üí Clarify ‚Üí Research best practices ‚Üí Plan steps ‚Üí Execute ‚Üí Validate ‚Üí Commit.
- Use slash commands or equivalent for mapping, QA, refactoring, and debugging.

## 8. Technical Standards
- Follow strict TypeScript/ESLint conventions for naming, typing, and error handling.
- Plan in concrete steps, not timeframes.
- Enforce security best practices: never store secrets, always validate input, handle errors securely.

## 9. Implementation Patterns
- Use centralized, type-safe error handling.
- Prefer `unknown` over `any` in catch blocks.
‚îÇ  ‚îú‚îÄ signatureProvider.ts     ‚Ä¢ Function signature help
‚îÇ  ‚îú‚îÄ provider.ts              ‚Ä¢ Base provider utilities
‚îÇ  ‚îî‚îÄ slashCommandProvider.ts  ‚Ä¢ Special command handling
‚îú‚îÄ client/
‚îÇ  ‚îî‚îÄ extension.ts             ‚Ä¢ VS Code extension activation
‚îú‚îÄ server/src/                 ‚Ä¢ (legacy structure, may need cleanup)
‚îú‚îÄ syntaxes/
‚îÇ  ‚îú‚îÄ functions.json           ‚Ä¢ üîë Function catalog (SSOT)
‚îÇ  ‚îú‚îÄ twbl.tmLanguage.json     ‚Ä¢ üîë TextMate grammar
‚îÇ  ‚îî‚îÄ twbl.d.twbl             ‚Ä¢ üîë Semantic token definitions
‚îî‚îÄ snippets/                   ‚Ä¢ Code snippets and slash commands
```

## Critical dependencies (NEVER modify without coordination)

1. **`syntaxes/functions.json`** ‚Äì Single source of truth for function signatures, return types, documentation
2. **`syntaxes/twbl.tmLanguage.json`** ‚Äì Authoritative TextMate grammar for .twbl syntax highlighting  
3. **`syntaxes/twbl.d.twbl`** ‚Äì Semantic token legend for LODs, window calculations, field types

## Known issues & technical debt

1. **Diagnostics refresh**: Diagnostics don't update after initial file analysis
2. **Signature Help parameters**: `activeParameter` calculation is broken (returns -1)
3. **Document synchronization**: Text changes may not properly invalidate cached models
4. **Error handling**: Server crashes on malformed input instead of graceful degradation
5. **Performance**: Large .twbl files cause blocking operations

## Language-specific requirements

- **Tableau-only focus**: Eliminate ALL references to AutoHotkey, Zig, or other languages in code/docs
- **File extensions**: Primary target is `.twbl` files (Tableau workbook calculations)
- **Syntax awareness**: Must understand LODs, window functions, field references, calculation context
- **Function catalog**: All hover/completion MUST derive from `syntaxes/functions.json`

## Coding & build conventions

- **TypeScript strict mode**: No `any` types, explicit return types for public methods
- **ESLint compliance**: Respect existing overrides for naming-convention, no-unused-vars
- **Build system**: Uses `esbuild` via `esbuild1.mjs`; VS Code extension host for debugging
- **Error handling**: Prefer graceful degradation over crashes; log errors for diagnostics
- **Performance**: Async operations for file I/O; incremental parsing for large documents
- **Testing**: Use Node `assert` + `ts-node` when tests are added (no heavy runners)

## AI interaction rules

### When fixing bugs or adding features:

1. **Patch format only** ‚Äì provide minimal, focused code changes:
   ```typescript
   // src/diagnosticsProvider.ts
   @@ before
   // old code here
   @@ after  
   // new code here
   // Brief 1-line rationale
   ```

2. **Context assumptions**: 
   - User can provide additional code snippets on request
   - Focus on the specific LSP request/response cycle
   - Reference the three critical dependency files when relevant

3. **No theory dumps**: Skip architectural explanations unless specifically requested

### When guidance is needed:

- **Ask specific questions** about missing context (file contents, error messages, expected behavior)
- **Point to LSP hooks** and data flow rather than full implementations  
- **Reference existing patterns** in the codebase for consistency

### Quality gates:

- Every change must maintain TypeScript compilation
- LSP requests must return proper JSON-RPC responses
- Features should degrade gracefully on parse errors
- Document model updates must be atomic and consistent

## Development workflow

1. **Debug setup**: Use VS Code extension host (`F5`) for live testing
2. **Build command**: `npm run build` via esbuild configuration
3. **Test files**: Use provided `.twbl` files in repo root for validation
4. **LSP tracing**: Enable `"tableau-lsp.trace.server": "verbose"` in VS Code settings

---

*Optimized for rapid, focused development of production-ready Tableau language tooling.* 